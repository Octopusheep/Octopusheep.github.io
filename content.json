{"pages":[{"title":"about","text":"He gives man speech, speech created thought, which is measure of the universe. I remember this phrase from Thinking in Java(4th Edition) So I save what I wanna save in this website including my thought, which is mean of why I build it.","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"Android MVP框架学习笔记","text":"本学习笔记总结自文章MVP模式简单易懂的介绍方式 MVP即Model-View-Presenter设计模式，相比于MVC设计模式，将MVC中View层的业务逻辑抽离至Presenter层中，使整个框架的耦合度进一步降低。 MVC与MVPMVC即模型-视图-控制器设计模式 View层：应用程序的UI界面，负责向用户展示数据和接受用户的输入 Model层：JavaBean实体类，负责保存实例数据 Controller层：更新用于用户界面，和数据实例 Android中MVP设计模式的核心思想： MVP把Activity中的UI逻辑抽象成View接口，把业务逻辑抽象成Presenter接口，Model类还是原来的Model。 这样做简化了Activity的工作，只用来响应生命周期，其他工作都丢到Presenter层中去完成。为了充分体现MVP的思想，View层不能直接对Model层进行操作，这是MVP与MVC最大的不同。 MVP模式具体的应用 使用MVP至少要做如下步骤： 创建IPresenter接口，把所有业务逻辑的接口放在这里，并创建他们的实现类PresenterCompl，在PresenterCompl类中写具体的业务逻辑 创建IView接口，把所有视图逻辑的接口放在这里，其实现类是Activity或Fragment Model不一定要存在，但是一定会有View和Presenter 根据我的理解，View层和Presenter层相互持有彼此的引用，因此View层中的逻辑操作可以通过操纵Presenter层的引用完成，而Presenter层可以通过操纵View层的引用更新UI界面，View层无法直接接触Model层，必须通过Presnter层中持有的View层引用，来更新UI界面，这样三层之间实现充分解耦。","link":"/2018/10/08/Android MVP框架学习笔记1/"},{"title":"Android MVP框架学习笔记","text":"本学习笔记总结自文章MVP模式简单易懂的介绍方式 MVP即Model-View-Presenter设计模式，相比于MVC设计模式，将MVC中View层的业务逻辑抽离至Presenter层中，使整个框架的耦合度进一步降低。 MVC与MVPMVC即模型-视图-控制器设计模式 View层：应用程序的UI界面，负责向用户展示数据和接受用户的输入 Model层：JavaBean实体类，负责保存实例数据 Controller层：更新用于用户界面，和数据实例 Android中MVP设计模式的核心思想： MVP把Activity中的UI逻辑抽象成View接口，把业务逻辑抽象成Presenter接口，Model类还是原来的Model。 这样做简化了Activity的工作，只用来响应生命周期，其他工作都丢到Presenter层中去完成。为了充分体现MVP的思想，View层不能直接对Model层进行操作，这是MVP与MVC最大的不同。 MVP模式具体的应用 使用MVP至少要做如下步骤： 创建IPresenter接口，把所有业务逻辑的接口放在这里，并创建他们的实现类PresenterCompl，在PresenterCompl类中写具体的业务逻辑 创建IView接口，把所有视图逻辑的接口放在这里，其实现类是Activity或Fragment Model不一定要存在，但是一定会有View和Presenter 根据我的理解，View层和Presenter层相互持有彼此的引用，因此View层中的逻辑操作可以通过操纵Presenter层的引用完成，而Presenter层可以通过操纵View层的引用更新UI界面，View层无法直接接触Model层，必须通过Presnter层中持有的View层引用，来更新UI界面，这样三层之间实现充分解耦。","link":"/2018/10/08/Android MVP框架学习笔记1的副本/"},{"title":"AndroidStudio常用快捷键指南","text":"常用命令 alt+up/down 在类和方法间移动光标 ctrl+f12 弹出文件中类和方法的结构图，按esc取消 ctrl+alr+h 展示一个方法调用路径层级图 ctrl+shift+i 弹出展示代码具体实现的小框 ctrl+shift+a 查找Android Studio中的动作或命令（Analyze Data Flow to Here） ctrl+y 删除整行 ctrl+shift+delete 移除外层包围的代码 ctrl+j 弹出动态模板代码提示框 alt+MouseDrag 拉长光标 ctrl+o 快速复写方法","link":"/2018/08/24/AndroidStudio常用快捷键指南/"},{"title":"AndroidStudio常用快捷键指南","text":"常用命令 alt+up/down 在类和方法间移动光标 ctrl+f12 弹出文件中类和方法的结构图，按esc取消 ctrl+alr+h 展示一个方法调用路径层级图 ctrl+shift+i 弹出展示代码具体实现的小框 ctrl+shift+a 查找Android Studio中的动作或命令（Analyze Data Flow to Here） ctrl+y 删除整行 ctrl+shift+delete 移除外层包围的代码 ctrl+j 弹出动态模板代码提示框 alt+MouseDrag 拉长光标 ctrl+o 快速复写方法","link":"/2018/08/24/AndroidStudio常用快捷键指南的副本/"},{"title":"Android开发环境配置(Ubuntu环境)","text":"安装Java development kit (JDK) 从oracle官网下载jdk，选择Linux x64版本,下载完成后，复制到桌面 在/usr/local目录下创建java文件夹 进入终端，输入 sudo mkdir /usr/local/java进入终端，输入 sudo cp -r jdk-8u171-linux-x64.tar.gz /usr/local/java进入终端，输入 sudo tar -xzvf sudo mkdir /usr/local/java 使用文本编辑器修改/home//.bashrc文件,末尾追加 export JAVA_HOME=/usr/local/java/jdk1.8.0_171export JRE_HOME=${JAVA_HOME}/jreexport CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/libexport PATH=${JAVA_HOME}/bin:$PATH 重启系统后，jdk即安装成功 安装Android studio(Linux) 下载Linux版本的Android studio安装包 进入./bin文件夹中右键打开终端 输入sudo sh studio.sh 依次执行即可完成安装 配置android studi启动图标 在桌面进入终端，输入指令 gedit android_studio.desktop 在文本编辑器中添加下列信息 [Desktop Entry]Name = Android StudioComment= android studioExec=/opt/android-studio/bin/studio.shIcon=/opt/android-studio/bin/studio.pngTerminal=falseType=Application 安装shadowsocks-qt5 命令行安装ShadowSocks sudo add-apt-repository ppa:hzwhuang/ss-qt5sudo apt-get updatesudo apt-get install shadowsocks-qt5 使用Ubnutu18.04安装Shadowsocks-Qt5时,同样使用sudo add-apt-repository ppa:hzwhuang/ss-qt5添加源，但是ppa:hzwhuang/ss-qt5并没有18.04版本的源，所以再执行update时会出现如下错误: 仓库 “http://ppa.launchpad.net/hzwhuang/ss-qt5/ubuntu bionic Release” 没有 Release 文件 这时，只要编辑/etc/apt/sources.list.d/hzwhuang-ubuntu-ss-qt5-bionic.list文件，将bionic (18.04版本代号)改成xenial（16.04版本代号）.然后再执行sudo apt-get update. 成功之后就是sudo apt-get install shadowsocks-qt5 安装Chrome浏览器 在Firefox浏览器设置中编辑SOCKS主机和端口号分别为127.0.0.1和1080 在Ubuntu系统网络设置中按如下配置网络代理 成功翻墙后安装Chrome浏览器","link":"/2018/08/24/Android开发环境配置(Ubuntu环境)/"},{"title":"Android开发环境配置(Ubuntu环境)","text":"安装Java development kit (JDK) 从oracle官网下载jdk，选择Linux x64版本,下载完成后，复制到桌面 在/usr/local目录下创建java文件夹 进入终端，输入 sudo mkdir /usr/local/java进入终端，输入 sudo cp -r jdk-8u171-linux-x64.tar.gz /usr/local/java进入终端，输入 sudo tar -xzvf sudo mkdir /usr/local/java 使用文本编辑器修改/home//.bashrc文件,末尾追加 export JAVA_HOME=/usr/local/java/jdk1.8.0_171export JRE_HOME=${JAVA_HOME}/jreexport CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/libexport PATH=${JAVA_HOME}/bin:$PATH 重启系统后，jdk即安装成功 安装Android studio(Linux) 下载Linux版本的Android studio安装包 进入./bin文件夹中右键打开终端 输入sudo sh studio.sh 依次执行即可完成安装 配置android studi启动图标 在桌面进入终端，输入指令 gedit android_studio.desktop 在文本编辑器中添加下列信息 [Desktop Entry]Name = Android StudioComment= android studioExec=/opt/android-studio/bin/studio.shIcon=/opt/android-studio/bin/studio.pngTerminal=falseType=Application 安装shadowsocks-qt5 命令行安装ShadowSocks sudo add-apt-repository ppa:hzwhuang/ss-qt5sudo apt-get updatesudo apt-get install shadowsocks-qt5 使用Ubnutu18.04安装Shadowsocks-Qt5时,同样使用sudo add-apt-repository ppa:hzwhuang/ss-qt5添加源，但是ppa:hzwhuang/ss-qt5并没有18.04版本的源，所以再执行update时会出现如下错误: 仓库 “http://ppa.launchpad.net/hzwhuang/ss-qt5/ubuntu bionic Release” 没有 Release 文件 这时，只要编辑/etc/apt/sources.list.d/hzwhuang-ubuntu-ss-qt5-bionic.list文件，将bionic (18.04版本代号)改成xenial（16.04版本代号）.然后再执行sudo apt-get update. 成功之后就是sudo apt-get install shadowsocks-qt5 安装Chrome浏览器 在Firefox浏览器设置中编辑SOCKS主机和端口号分别为127.0.0.1和1080 在Ubuntu系统网络设置中按如下配置网络代理 成功翻墙后安装Chrome浏览器","link":"/2018/08/24/Android开发环境配置(Ubuntu环境)的副本/"},{"title":"Flutter学习笔记(Tour the framework)","text":"Introduction Flutter widget are built by a modern react-style framework and the widget have their own configuration and state which can support the rebuilt process when those two varieties changes Hello Worldthe simpiest flutter application likes this: 123456789101112import &apos;package:flutter/material.dart&apos;;void main(){ runApp( Center( child: Text( &apos;Hello,world!&apos;, textDirection: TextDirection.lrt, ), ), );} the runApp function take the given Widget and makes it the root of the widget tree. the flutter framework force the root widget to cover the screen. the text direction needs to be specified in this instance. the coder can author new widgets that are subclasses of either statelessWidget or statefulWidget the diffs of two kind of Widget is that whether your widget manages any state. A widget’s main job is to implement a build function, which describes the widget in terms of other, lower-lever widgets the framework builds those wodgets in turn until this process bottoms out in widgets that represent the underlying RenderObject, which computes and describes the geometry og the widget. Basic widget Text Row,Column Stack Container many widgets need to be inside of a MaterialApp to display properly, in order to inherit theme date. the widget can be marked as Expanded, which means it expands to fill any remainong available apce that hasn’t been consumed by the other children. you can have multiple Expanded children and determine the ratio in which they consume th available space using the flex argument to Expanded. Important: Passing widgets as argument to other widgets is a powerful technique that lets you create generic widgets that cann be reused in a wide variety of ways. Using material componentA material app starts with the MaterialApp widget. Navigator widget manages a stasck of widgets identified by strings , also known as route, which lets you transition smoothly between screeens of your application. Handling gesturethe GestureDetector widget doesn’t hava a visual representation but instead detect gestures made by the user, including taps, drags, and scales. Changing widgets in response to inputStatelessWidgets receive argument from their parent widget, which they store on final member variables. StatefulWidgets are special widgets that know how to generate State objects, which are then used to hold state.","link":"/2018/10/02/Flutter学习笔记(Tour the framework)/"},{"title":"Flutter学习笔记(Tour the framework)","text":"Introduction Flutter widget are built by a modern react-style framework and the widget have their own configuration and state which can support the rebuilt process when those two varieties changes Hello Worldthe simpiest flutter application likes this: 123456789101112import &apos;package:flutter/material.dart&apos;;void main(){ runApp( Center( child: Text( &apos;Hello,world!&apos;, textDirection: TextDirection.lrt, ), ), );} the runApp function take the given Widget and makes it the root of the widget tree. the flutter framework force the root widget to cover the screen. the text direction needs to be specified in this instance. the coder can author new widgets that are subclasses of either statelessWidget or statefulWidget the diffs of two kind of Widget is that whether your widget manages any state. A widget’s main job is to implement a build function, which describes the widget in terms of other, lower-lever widgets the framework builds those wodgets in turn until this process bottoms out in widgets that represent the underlying RenderObject, which computes and describes the geometry og the widget. Basic widget Text Row,Column Stack Container many widgets need to be inside of a MaterialApp to display properly, in order to inherit theme date. the widget can be marked as Expanded, which means it expands to fill any remainong available apce that hasn’t been consumed by the other children. you can have multiple Expanded children and determine the ratio in which they consume th available space using the flex argument to Expanded. Important: Passing widgets as argument to other widgets is a powerful technique that lets you create generic widgets that cann be reused in a wide variety of ways. Using material componentA material app starts with the MaterialApp widget. Navigator widget manages a stasck of widgets identified by strings , also known as route, which lets you transition smoothly between screeens of your application. Handling gesturethe GestureDetector widget doesn’t hava a visual representation but instead detect gestures made by the user, including taps, drags, and scales. Changing widgets in response to inputStatelessWidgets receive argument from their parent widget, which they store on final member variables. StatefulWidgets are special widgets that know how to generate State objects, which are then used to hold state.","link":"/2018/10/02/Flutter学习笔记(Tour the framework)的副本/"},{"title":"Flutter安装指南(Ubuntu环境)","text":"前言根据flutter官网的说法 Flutter是谷歌的移动UI框架，可以快速在iOS和Android上构建高质量的原生用户界面。 其优点总结起来包括： 亚秒级别的热重载 媲美原生应用的性能 丰富的UI 个人认为flutter作为一个跨平台的UI框架，热重载是其最吸引人的功能，笔者目前负责的新闻项目涉及到切换主题后，应用内部的部分组件颜色也要随主题颜色变化，使用flutter框架进行开发，可以直接热重载应用界面而不用重走应用的生命周期，考虑到种种因素，故对flutter做预研。 主要步骤已由Flutter中文网给出，我重新整理了一下。 获取Flutter SDK 在Flutter官网下载Flutter SDK 右键或命令行解压安装包到你想安装的路径 1xz -d flutter_linux_v0.8.2-beta.tar.xz 1tar -xvf flutter_linux_v0.8.2-beta.tar 解压完成后将flutter文件夹拷贝到你想安装的路径 配置环境变量 将以下代码复制到主目录的.bashrc目录中 123export PUB_HOSTED_URL=https://pub.flutter-io.cn //国内用户需要设置export FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn //国内用户需要设置export PATH= PATH_TO_FLUTTER_GIT_DIRECTORY/flutter/bin:$PATH 注意：PATH_TO_FLUTTER_GIT_DIRECTORY为flutter目录的路径，比如笔者将其放在了/home/zhangyuyang/Android中 1export PATH=/home/zhangyuyang/Android/flutter/bin:$PATH 刷新PATH路径 1source $HOME/.bashrc 用echo命令查看flutter目录是否在PATH路径中 1echo $PATH 检查是否需要其他依赖项1flutter doctor 根据提示安装所需的依赖，再次运行flutter doctor命令，若提示如下图所示无任何问题，即完成flutter安装： 安装Flutter和Dart插件需要在Android Studio中安装两个插件: Flutter插件： 支持Flutter开发工作流 (运行、调试、热重载等). Dart插件： 提供代码分析 (输入代码时进行验证、代码补全等). 要安装这些: 启动Android Studio. 打开插件首选项 (File&gt;Settings&gt;Plugins). 选择 Browse repositories…, 选择 Flutter 插件并点击 install. 重启Android Studio后插件生效.","link":"/2018/09/29/Flutter安装指南(Ubuntu环境)/"},{"title":"Flutter安装指南(Ubuntu环境)","text":"前言根据flutter官网的说法 Flutter是谷歌的移动UI框架，可以快速在iOS和Android上构建高质量的原生用户界面。 其优点总结起来包括： 亚秒级别的热重载 媲美原生应用的性能 丰富的UI 个人认为flutter作为一个跨平台的UI框架，热重载是其最吸引人的功能，笔者目前负责的新闻项目涉及到切换主题后，应用内部的部分组件颜色也要随主题颜色变化，使用flutter框架进行开发，可以直接热重载应用界面而不用重走应用的生命周期，考虑到种种因素，故对flutter做预研。 主要步骤已由Flutter中文网给出，我重新整理了一下。 获取Flutter SDK 在Flutter官网下载Flutter SDK 右键或命令行解压安装包到你想安装的路径 1xz -d flutter_linux_v0.8.2-beta.tar.xz 1tar -xvf flutter_linux_v0.8.2-beta.tar 解压完成后将flutter文件夹拷贝到你想安装的路径 配置环境变量 将以下代码复制到主目录的.bashrc目录中 123export PUB_HOSTED_URL=https://pub.flutter-io.cn //国内用户需要设置export FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn //国内用户需要设置export PATH= PATH_TO_FLUTTER_GIT_DIRECTORY/flutter/bin:$PATH 注意：PATH_TO_FLUTTER_GIT_DIRECTORY为flutter目录的路径，比如笔者将其放在了/home/zhangyuyang/Android中 1export PATH=/home/zhangyuyang/Android/flutter/bin:$PATH 刷新PATH路径 1source $HOME/.bashrc 用echo命令查看flutter目录是否在PATH路径中 1echo $PATH 检查是否需要其他依赖项1flutter doctor 根据提示安装所需的依赖，再次运行flutter doctor命令，若提示如下图所示无任何问题，即完成flutter安装： 安装Flutter和Dart插件需要在Android Studio中安装两个插件: Flutter插件： 支持Flutter开发工作流 (运行、调试、热重载等). Dart插件： 提供代码分析 (输入代码时进行验证、代码补全等). 要安装这些: 启动Android Studio. 打开插件首选项 (File&gt;Settings&gt;Plugins). 选择 Browse repositories…, 选择 Flutter 插件并点击 install. 重启Android Studio后插件生效.","link":"/2018/09/29/Flutter安装指南(Ubuntu环境)的副本/"},{"title":"Git常用命令总结","text":"本地分支命令 创建版本库git init 添加文件至仓库git add 提交文件至仓库git commit -m &quot;本次提交的说明&quot; 查看版本库当前状态git status 查看上次修改内容git diff 显示从最近到最远的提交日志git log 回退到上一个版本git reset --hard HEAD^ 每一个命令的记录git reflog 查看工作区和版本库里最新版本的区别git diff HEAD -- file 丢弃工作区的修改git checkout -- file 切换分支git checkout branch 把暂存区的修改撤销掉，重新放回工作区git reset HEAD &lt;file&gt; 从版本库删除文件，并提交git rm &lt;file&gt;git commit -m &quot;remove &lt;file&gt;&quot; 从版本库恢复删错的文件（等同于丢弃工作区的修改） git checkout -- &lt;file&gt; 分支管理 创建分支git branch &lt;branch&gt; 创建新分支并切换到该分支git checkout -b &lt;branch&gt; 查看当前分支git branch当前分支前会标一个*号 切换分支git checkout &lt;branch&gt; 合并指定分支到当前分支git merge &lt;dev branch&gt; 删除分支git branch -d &lt;branch&gt; 禁用fast forward模式合并分支git merge --no-ff -m &quot;merge with no-ff&quot; dev 藏匿当前工作现场git stash 查看藏匿的工作现场git stash list 恢复藏匿的工作现场git stash apply 删除stash内容git stash drop 恢复工作现场的同时并删除stash内容git stash pop 删除没有被合并过的分支git branch -D &lt;branch&gt; 查看远程仓库信息git remote, 更详细的信息用git remote -v 推送分支git push origin master 创建远程仓库的分支到本地git checkout -b dev origin/dev 抓取远程的新提交git pull 建立本地分支和远程分支的关联git branch --set-upstream dev origin/dev Git Cheat Sheet","link":"/2018/08/20/Git常用命令总结/"},{"title":"Git常用命令总结","text":"本地分支命令 创建版本库git init 添加文件至仓库git add 提交文件至仓库git commit -m &quot;本次提交的说明&quot; 查看版本库当前状态git status 查看上次修改内容git diff 显示从最近到最远的提交日志git log 回退到上一个版本git reset --hard HEAD^ 每一个命令的记录git reflog 查看工作区和版本库里最新版本的区别git diff HEAD -- file 丢弃工作区的修改git checkout -- file 切换分支git checkout branch 把暂存区的修改撤销掉，重新放回工作区git reset HEAD &lt;file&gt; 从版本库删除文件，并提交git rm &lt;file&gt;git commit -m &quot;remove &lt;file&gt;&quot; 从版本库恢复删错的文件（等同于丢弃工作区的修改） git checkout -- &lt;file&gt; 分支管理 创建分支git branch &lt;branch&gt; 创建新分支并切换到该分支git checkout -b &lt;branch&gt; 查看当前分支git branch当前分支前会标一个*号 切换分支git checkout &lt;branch&gt; 合并指定分支到当前分支git merge &lt;dev branch&gt; 删除分支git branch -d &lt;branch&gt; 禁用fast forward模式合并分支git merge --no-ff -m &quot;merge with no-ff&quot; dev 藏匿当前工作现场git stash 查看藏匿的工作现场git stash list 恢复藏匿的工作现场git stash apply 删除stash内容git stash drop 恢复工作现场的同时并删除stash内容git stash pop 删除没有被合并过的分支git branch -D &lt;branch&gt; 查看远程仓库信息git remote, 更详细的信息用git remote -v 推送分支git push origin master 创建远程仓库的分支到本地git checkout -b dev origin/dev 抓取远程的新提交git pull 建立本地分支和远程分支的关联git branch --set-upstream dev origin/dev Git Cheat Sheet","link":"/2018/08/20/Git常用命令总结的副本/"},{"title":"Golang安装指南(Ubuntu环境)","text":"Go is an open source programming language that makes it easy to build simple, reliable, and efficient software. all the content in this article can find in Go official document Download the Go distributionwe can download go from Go official website and choice the right distribution of Go,the latest verison is 1.12.5 until I wrote this article: 1go1.12.5.linux-amd64.tar.gz Install the Go tools extract the archive into /usr/local 1tar -C -xzf go1.12.5.linux-amd64.tar.gz add PATH environment variable into /etc/profile 12345#golangexport GOROOT=/usr/local/goexport GOBIN=$GOROOT/binexport GOPATH=$HOME/workspace/goexport PATH=$PATH:$GOROOT/bin restart your computerthe changes will apply until next time your log into your computer Attentionthe install process in Go official guide have some misunderstanding part,such as the effect PATH environment variable is not export PATH=$PATH:/usr/local/go/bin,its not enough for runing go on Ubuntu.","link":"/2019/05/15/Golang安装指南(Ubuntu环境)/"},{"title":"Golang安装指南(Ubuntu环境)","text":"Go is an open source programming language that makes it easy to build simple, reliable, and efficient software. all the content in this article can find in Go official document Download the Go distributionwe can download go from Go official website and choice the right distribution of Go,the latest verison is 1.12.5 until I wrote this article: 1go1.12.5.linux-amd64.tar.gz Install the Go tools extract the archive into /usr/local 1tar -C -xzf go1.12.5.linux-amd64.tar.gz add PATH environment variable into /etc/profile 12345#golangexport GOROOT=/usr/local/goexport GOBIN=$GOROOT/binexport GOPATH=$HOME/workspace/goexport PATH=$PATH:$GOROOT/bin restart your computerthe changes will apply until next time your log into your computer Attentionthe install process in Go official guide have some misunderstanding part,such as the effect PATH environment variable is not export PATH=$PATH:/usr/local/go/bin,its not enough for runing go on Ubuntu.","link":"/2019/05/15/Golang安装指南(Ubuntu环境)的副本/"},{"title":"Golang教程学习笔记","text":"本文内容总结自菜鸟教程Go语言教程和Golang官网 Go is an open source programming language that makes it easy to build simple, reliable, and efficient software. 即Go 是一门开源的编程语言，使构建简单，可靠，有效的软件更加简单 go语言结构go语言的基础组成主要包括6个部分： 包声明 引入包 函数 变量 语句&amp;表达式 注释 示例代码： 123456package mainimport \"fmt\"func main(){ fmt.Println(\"hello world!\")} 第一行的package main定义了源文件的包名，我们必须在源文件非注释的第一行指明这个文件属于哪个包. package main表示该源文件为一个可独立执行的程序，每一个go应用程序都包含一个名为main的包 import “fmt”告诉go编译器这个程序需要使用fmt包（中的函数或其他元素），fmt包实现了格式化IO的函数 func main()是程序开始执行的函数，main函数是每一个可执行的程序所必需包含的，一般来说都是程序启动后第一个执行的函数（如果有init()函数则会先执行该函数） go的注释和java一样，分单行注释和多行注释 fmt.Println()可以将变量输出至控制台显示，实现格式化IO，输出函数有三种： Print Println Printf 和java的syso一样分别实现输出，输出换行，格式化输出，如果没有特别指定，print系函数将会以默认的打印格式输出变量 当一个identifier标识符（包括常量，变量，类型，函数名，结构字段等等）以一个大写字母开头，如Identifier1，那么使用这中标识符的对象就可以被外部包的代码所使用，前提是外部包需要先导入这个包；标识符如果已小写字母开头，则对外部包是不可见的，但是他们在整个包的内部是可用并可见的。这个特性像OOP中的public和protected关键字 {符号不能单独放在一行，否则代码在运行时会产生错误 执行go程序有两种方法 go run hello.go直接对源文件执行go run go build hello.go生成源文件的二进制文件，再运行该文件 go语言基本语法","link":"/2019/05/29/Golang教程学习笔记/"},{"title":"Golang教程学习笔记","text":"本文内容总结自菜鸟教程Go语言教程和Golang官网 Go is an open source programming language that makes it easy to build simple, reliable, and efficient software. 即Go 是一门开源的编程语言，使构建简单，可靠，有效的软件更加简单 go语言结构go语言的基础组成主要包括6个部分： 包声明 引入包 函数 变量 语句&amp;表达式 注释 示例代码： 123456package mainimport \"fmt\"func main(){ fmt.Println(\"hello world!\")} 第一行的package main定义了源文件的包名，我们必须在源文件非注释的第一行指明这个文件属于哪个包. package main表示该源文件为一个可独立执行的程序，每一个go应用程序都包含一个名为main的包 import “fmt”告诉go编译器这个程序需要使用fmt包（中的函数或其他元素），fmt包实现了格式化IO的函数 func main()是程序开始执行的函数，main函数是每一个可执行的程序所必需包含的，一般来说都是程序启动后第一个执行的函数（如果有init()函数则会先执行该函数） go的注释和java一样，分单行注释和多行注释 fmt.Println()可以将变量输出至控制台显示，实现格式化IO，输出函数有三种： Print Println Printf 和java的syso一样分别实现输出，输出换行，格式化输出，如果没有特别指定，print系函数将会以默认的打印格式输出变量 当一个identifier标识符（包括常量，变量，类型，函数名，结构字段等等）以一个大写字母开头，如Identifier1，那么使用这中标识符的对象就可以被外部包的代码所使用，前提是外部包需要先导入这个包；标识符如果已小写字母开头，则对外部包是不可见的，但是他们在整个包的内部是可用并可见的。这个特性像OOP中的public和protected关键字 {符号不能单独放在一行，否则代码在运行时会产生错误 执行go程序有两种方法 go run hello.go直接对源文件执行go run go build hello.go生成源文件的二进制文件，再运行该文件 go语言基本语法","link":"/2019/05/29/Golang教程学习笔记的副本/"},{"title":"Hexo使用指南一(Ubuntu环境)","text":"前言按照Hexo官网的说法 Hexo 是一个快速、简洁且高效的博客框架. Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页. 利用Hexo,我们可以用极低的成本构建属于自己的博客，并且自动为博文分类和归档，这篇教程是我使用Hexo构建个人博客时候做的总结. 这份Hexo使用指南适用于Ubuntu环境，写这份指南时所用的操作系统版本为Ubuntu18.04.通过这份Hexo使用指南一，你可以快速掌握本地部署博客的方法. 完成本教程后，下一教程将会向您展示如何花费人民币1元的代价，购入属于自己的域名并与本教程中本地存在的Hexo博客关联. 安装前期环境在运行Hexo之前，需要安装两个必备的工具Node.js和Git. 在Terminal中执行以下命令： 安装Node.js 1$ sudo apt-get install nodejs 安装Git1$ sudo apt-get install git 安装Hexo安装完Hexo运行所必备的两个组件后，接下来就可以安装Hexo啦 安装Hexo 1$ sudo npm install hexo-cli -g 安装Hexo完成后可以使用 1$ hexo -v 查看Hexo是否正确安装上 初始化Hexo环境 创建您想保存Hexo的文件夹(建议在主目录下新建blog文件夹，便于使用和管理所有blog) 1$ mkdir blog 进入blog文件夹下 1$ cd blog 初始化Hexo环境(此处叫myblog1,可自定义Hexo环境文件夹名，最好与域名相同，便于查找和管理) 1~/blog$ hexo init myblog1 上述命令执行完成后，可发现/blog文件夹中，新出现了一个myblog1文件夹 进入myblog1文件夹发现其文件结构如下： 其中 node_modules : 依赖包 scaffolds : 生成文章的模板 source : 所有博客文章 themes : 主题 _config.yml : 博客的配置文件 db.json : 解析source的到的文件 package.json : Hexo及其依赖包的版本信息 本教程中使用的只有_config.yml文件和source, themes文件夹 清空Hexo环境 1$ hexo clean 生成Hexo静态文件 1$ hexo generate 上传到本地虚拟服务器 1$ hexo server 当命令行出现以下内容，恭喜你，您的博客已成功部署在本地虚拟服务器，点击链接http://localhost:4000/即可在浏览器中查看自己的博客 发布文章 在myblog1目录下使用hexo new post &lt;博文名&gt;来创建新博文,例如：1$ hexo new post myfirstblogarticle hexo new [layout] &lt;title&gt;命令的layout参数有三种,分别为： post : 发布博文 page : 发布新页面 draft : 发布草稿 具体区别和更多关于Hexo博文的知识点可在Hexo官网的 帮助文档中查看 进入source目录中的_posts目录，新创建的myfirstblogarticle.md博文被创建在此，格式为markdown,可在简书的markdown新手指南中了解书写博客的基本格式. 使用主题博客的主题最能体现博主的风格，相信大家都很在意. Hexo初始化环境默认使用的皮肤为landscape,更多皮肤可以在Hexo官网的themes中挑选并拷贝到themes文件夹中，本教程用hipaper主题作介绍 进入themes文件夹,用git将hipaper主题下载至文件夹内1$ git clone git@github.com:iTimeTraveler/hexo-theme-hipaper.git 如果不会使用Git，建议查看廖雪峰的Git教程 为使用主题的搜索功能，需安装hexo-generator-json-content 工具 1$ npm install -S hexo-generator-json-content 为hipaper主题配置tags, categories, about页面 由于hipaper主题默认只开启了archives(归档)功能，所以标签，分类，简介页面需要靠代码开启 123$ hexo new page tags$ hexo new page categories$ hexo new page about 执行完毕进入source文件夹，发现其中多了about, categories, tags三个子文件夹，且都包含一个名为index.md的文件，以/soucce/about/index.md为例，分别将三个不同的index.md文件中加入一行代码 原代码为： 1234---title: aboutdate: xxxx-xx-xx xx:xx:xx--- 增加一行代码，改为： 12345---title: aboutdate: xxxx-xx-xx xx:xx:xxlayout: about--- tags和categoroes文件夹中的index.md文件也作相应更改，layout参数值就是title参数值,至此，hipaper主题配置完成.","link":"/2018/08/14/Hexo使用指南一(Ubuntu环境)/"},{"title":"Hexo使用指南一(Ubuntu环境)","text":"前言按照Hexo官网的说法 Hexo 是一个快速、简洁且高效的博客框架. Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页. 利用Hexo,我们可以用极低的成本构建属于自己的博客，并且自动为博文分类和归档，这篇教程是我使用Hexo构建个人博客时候做的总结. 这份Hexo使用指南适用于Ubuntu环境，写这份指南时所用的操作系统版本为Ubuntu18.04.通过这份Hexo使用指南一，你可以快速掌握本地部署博客的方法. 完成本教程后，下一教程将会向您展示如何花费人民币1元的代价，购入属于自己的域名并与本教程中本地存在的Hexo博客关联. 安装前期环境在运行Hexo之前，需要安装两个必备的工具Node.js和Git. 在Terminal中执行以下命令： 安装Node.js 1$ sudo apt-get install nodejs 安装Git1$ sudo apt-get install git 安装Hexo安装完Hexo运行所必备的两个组件后，接下来就可以安装Hexo啦 安装Hexo 1$ sudo npm install hexo-cli -g 安装Hexo完成后可以使用 1$ hexo -v 查看Hexo是否正确安装上 初始化Hexo环境 创建您想保存Hexo的文件夹(建议在主目录下新建blog文件夹，便于使用和管理所有blog) 1$ mkdir blog 进入blog文件夹下 1$ cd blog 初始化Hexo环境(此处叫myblog1,可自定义Hexo环境文件夹名，最好与域名相同，便于查找和管理) 1~/blog$ hexo init myblog1 上述命令执行完成后，可发现/blog文件夹中，新出现了一个myblog1文件夹 进入myblog1文件夹发现其文件结构如下： 其中 node_modules : 依赖包 scaffolds : 生成文章的模板 source : 所有博客文章 themes : 主题 _config.yml : 博客的配置文件 db.json : 解析source的到的文件 package.json : Hexo及其依赖包的版本信息 本教程中使用的只有_config.yml文件和source, themes文件夹 清空Hexo环境 1$ hexo clean 生成Hexo静态文件 1$ hexo generate 上传到本地虚拟服务器 1$ hexo server 当命令行出现以下内容，恭喜你，您的博客已成功部署在本地虚拟服务器，点击链接http://localhost:4000/即可在浏览器中查看自己的博客 发布文章 在myblog1目录下使用hexo new post &lt;博文名&gt;来创建新博文,例如：1$ hexo new post myfirstblogarticle hexo new [layout] &lt;title&gt;命令的layout参数有三种,分别为： post : 发布博文 page : 发布新页面 draft : 发布草稿 具体区别和更多关于Hexo博文的知识点可在Hexo官网的 帮助文档中查看 进入source目录中的_posts目录，新创建的myfirstblogarticle.md博文被创建在此，格式为markdown,可在简书的markdown新手指南中了解书写博客的基本格式. 使用主题博客的主题最能体现博主的风格，相信大家都很在意. Hexo初始化环境默认使用的皮肤为landscape,更多皮肤可以在Hexo官网的themes中挑选并拷贝到themes文件夹中，本教程用hipaper主题作介绍 进入themes文件夹,用git将hipaper主题下载至文件夹内1$ git clone git@github.com:iTimeTraveler/hexo-theme-hipaper.git 如果不会使用Git，建议查看廖雪峰的Git教程 为使用主题的搜索功能，需安装hexo-generator-json-content 工具 1$ npm install -S hexo-generator-json-content 为hipaper主题配置tags, categories, about页面 由于hipaper主题默认只开启了archives(归档)功能，所以标签，分类，简介页面需要靠代码开启 123$ hexo new page tags$ hexo new page categories$ hexo new page about 执行完毕进入source文件夹，发现其中多了about, categories, tags三个子文件夹，且都包含一个名为index.md的文件，以/soucce/about/index.md为例，分别将三个不同的index.md文件中加入一行代码 原代码为： 1234---title: aboutdate: xxxx-xx-xx xx:xx:xx--- 增加一行代码，改为： 12345---title: aboutdate: xxxx-xx-xx xx:xx:xxlayout: about--- tags和categoroes文件夹中的index.md文件也作相应更改，layout参数值就是title参数值,至此，hipaper主题配置完成.","link":"/2018/08/14/Hexo使用指南一(Ubuntu环境)的副本/"},{"title":"Hexo使用指南二(Ubuntu环境)","text":"絮叨完成Hexo使用指南一中的步骤仅仅是将Hexo博客布置到本地的服务器中，怎么样让更多的人通过互联网直接访问你的博客呢？需要的仅仅是通过几个简单的步骤将你在指南一中生成的博客部署到github上. 通过github中你的个人域名来访问你的博客，这样所有人都可以在互联网上访问你的博客了. 值得一提的是，github所提供的个人域名的标准格式为username.github.io, 其中username为你注册的github账号用户名. 虽然域名形式上已经很简单了，但更多的人还是喜欢自己个性化定制的域名, 例如理发店的tony老师可能希望自己的博客域名为tony.com而不是相对复杂的tony.github.io, 本套教程就教你如何用一元人民币的代价来部署属于你的博客在你的个人域名上. 因此完成本套教程的前提为： 注册一个github账号 拥有一块钱 新建github个人域名repository 百度百科对github网站的定义为： gitHub是一个面向开源及私有软件项目的托管平台，因为只支持git 作为唯一的版本库格式进行托管，故名gitHub 注册并登陆github 新建reposotory(后均简称repo)repo可理解为保存代码的仓库，点击主页右上角的+符号，新建new repo命名为&lt;你的github账号名&gt;.github.io,如下所示： 复制该repo的SSH链接地址进入上述步骤建立的名为&lt;你的github账号名&gt;.github.io的repo，点击绿色的clone and download按钮选择SSH方式，复制链接如果主机没有为github配置SSH公匙，请百度一下如何为github配置SSH链接 建立本地Hexo博客与github个人域名的连接 打开mybolg1目录下的_config.yml文件，将文件底部的deploy:代码由 12deploy: type: 更改为 1234deploy: type: git repo: git@github.com:&lt;你的github账号名&gt;/&lt;你的github账号名&gt;.github.io.git //此处即填写复制的repo链接 branch: master 保存文件，并在Hexo博客的根目录下，按序执行： 清空Hexo缓存文件 1$ hexo clean 生成新的Hexo缓存文件 1$ hexo generate -部署Hexo至github仓库 1$ hexo deploy 待上述代码执行完毕，在网页中打开链接&lt;你的github账号名&gt;.github.io，如果你看到了你的个人博客，恭喜你，你已经成功在互联网上搭建了属于自己的个人博客了！ 注册个人自定义域名互联网上可以注册域名的网站有很多，例如阿里云, 腾讯云等. 本教程使用腾讯云来注册个人域名，其他网站的注册域名流程均大同小异. 注册一个域名 登陆腾讯云，根据自己的经济实力注册一个自己所需的域名，按步骤操作，最后交钱就行了.我们还以理发店的Tony老师为例，他注册了一个名为BarberTony.com的域名，由于这个域名档次较高，尊贵无比，所以租用该域名一年要价人民币59元，而笔者生活较为贫苦，无法大手笔购入高价域名，所以买了zhangyuyang.club的域名，租用该域名一年只需1元钱，合情合理，很舒服. 绑定Hexo域名与自定义域名 查看github个人域名外网IP在Terminal终端中用ping命令，查看github个人域名外网IP1$ ping &lt;你的github账号名&gt;.github.io 得到如下结果： 其中的185.199.110.153即为你的github个人域名外网IP 为您购买的自定义域名设置DNS解析进入腾讯云后台，点击我的域名，选择您购买的域名，点击域名解析-&gt;新手快速添加点击网站解析后，将主机地址设置为你的github个人域名外网IP 为Hexo本地文件配置自定义域名进入Hexo本地目录(本教程中为myblog1目录)中的source目录1$ cd source 在source目录下新建一个文件，名为CNAME,向其写入你购买的自定义域名 1$ gedit CNAME 保存文件，用hexo clean,hexo generate,hexo deploy命令重新部署Hexo至github. 打开浏览器，输入你的自定义域名，恭喜你，你已经在互联网上拥有属于自己的个性域名的博客了！","link":"/2018/08/15/Hexo使用指南二(Ubuntu环境)/"},{"title":"Hexo使用指南二(Ubuntu环境)","text":"絮叨完成Hexo使用指南一中的步骤仅仅是将Hexo博客布置到本地的服务器中，怎么样让更多的人通过互联网直接访问你的博客呢？需要的仅仅是通过几个简单的步骤将你在指南一中生成的博客部署到github上. 通过github中你的个人域名来访问你的博客，这样所有人都可以在互联网上访问你的博客了. 值得一提的是，github所提供的个人域名的标准格式为username.github.io, 其中username为你注册的github账号用户名. 虽然域名形式上已经很简单了，但更多的人还是喜欢自己个性化定制的域名, 例如理发店的tony老师可能希望自己的博客域名为tony.com而不是相对复杂的tony.github.io, 本套教程就教你如何用一元人民币的代价来部署属于你的博客在你的个人域名上. 因此完成本套教程的前提为： 注册一个github账号 拥有一块钱 新建github个人域名repository 百度百科对github网站的定义为： gitHub是一个面向开源及私有软件项目的托管平台，因为只支持git 作为唯一的版本库格式进行托管，故名gitHub 注册并登陆github 新建reposotory(后均简称repo)repo可理解为保存代码的仓库，点击主页右上角的+符号，新建new repo命名为&lt;你的github账号名&gt;.github.io,如下所示： 复制该repo的SSH链接地址进入上述步骤建立的名为&lt;你的github账号名&gt;.github.io的repo，点击绿色的clone and download按钮选择SSH方式，复制链接如果主机没有为github配置SSH公匙，请百度一下如何为github配置SSH链接 建立本地Hexo博客与github个人域名的连接 打开mybolg1目录下的_config.yml文件，将文件底部的deploy:代码由 12deploy: type: 更改为 1234deploy: type: git repo: git@github.com:&lt;你的github账号名&gt;/&lt;你的github账号名&gt;.github.io.git //此处即填写复制的repo链接 branch: master 保存文件，并在Hexo博客的根目录下，按序执行： 清空Hexo缓存文件 1$ hexo clean 生成新的Hexo缓存文件 1$ hexo generate -部署Hexo至github仓库 1$ hexo deploy 待上述代码执行完毕，在网页中打开链接&lt;你的github账号名&gt;.github.io，如果你看到了你的个人博客，恭喜你，你已经成功在互联网上搭建了属于自己的个人博客了！ 注册个人自定义域名互联网上可以注册域名的网站有很多，例如阿里云, 腾讯云等. 本教程使用腾讯云来注册个人域名，其他网站的注册域名流程均大同小异. 注册一个域名 登陆腾讯云，根据自己的经济实力注册一个自己所需的域名，按步骤操作，最后交钱就行了.我们还以理发店的Tony老师为例，他注册了一个名为BarberTony.com的域名，由于这个域名档次较高，尊贵无比，所以租用该域名一年要价人民币59元，而笔者生活较为贫苦，无法大手笔购入高价域名，所以买了zhangyuyang.club的域名，租用该域名一年只需1元钱，合情合理，很舒服. 绑定Hexo域名与自定义域名 查看github个人域名外网IP在Terminal终端中用ping命令，查看github个人域名外网IP1$ ping &lt;你的github账号名&gt;.github.io 得到如下结果： 其中的185.199.110.153即为你的github个人域名外网IP 为您购买的自定义域名设置DNS解析进入腾讯云后台，点击我的域名，选择您购买的域名，点击域名解析-&gt;新手快速添加点击网站解析后，将主机地址设置为你的github个人域名外网IP 为Hexo本地文件配置自定义域名进入Hexo本地目录(本教程中为myblog1目录)中的source目录1$ cd source 在source目录下新建一个文件，名为CNAME,向其写入你购买的自定义域名 1$ gedit CNAME 保存文件，用hexo clean,hexo generate,hexo deploy命令重新部署Hexo至github. 打开浏览器，输入你的自定义域名，恭喜你，你已经在互联网上拥有属于自己的个性域名的博客了！","link":"/2018/08/15/Hexo使用指南二(Ubuntu环境)的副本/"},{"title":"Java多线程基础","text":"当我们执行一些耗时操作时，如果不将这类操作放置在子线程中运行，可能导致主线程被堵塞。 多线程的用法1： 继承Thread类新建一个类继承Thread，然后重写父类的run()方法，在里面编写耗时逻辑。 1234567class SubThread extends Thread{ @Override public void run(){ //处理具体的逻辑 }} 启动线程只需要new出SubThread的实例，然后调用它的start()方法。 1new SubThread().start(); 多线程的用法2： 实现Runnable接口新建一个类实现Runnable接口，重写接口的run()方法 123456class SubThread implements Runnable{ @Override public void run(){ //处理具体的逻辑 }} 启动线程的需要new出实现了runnable接口的SubThread实例，将其传入Thread的构造函数中，接着调用Thread的start()方法。 多线程的用法3： Thread构造方法传入Runnable匿名类如果你不想专门定义一个类去实现Runnable接口，可以用匿名类的方式 12345678new Thread(new Runnable(){ @Override public void run(){ //处理具体的逻辑 }}).start();","link":"/2018/10/22/Java多线程基础/"},{"title":"Java多线程基础","text":"当我们执行一些耗时操作时，如果不将这类操作放置在子线程中运行，可能导致主线程被堵塞。 多线程的用法1： 继承Thread类新建一个类继承Thread，然后重写父类的run()方法，在里面编写耗时逻辑。 1234567class SubThread extends Thread{ @Override public void run(){ //处理具体的逻辑 }} 启动线程只需要new出SubThread的实例，然后调用它的start()方法。 1new SubThread().start(); 多线程的用法2： 实现Runnable接口新建一个类实现Runnable接口，重写接口的run()方法 123456class SubThread implements Runnable{ @Override public void run(){ //处理具体的逻辑 }} 启动线程的需要new出实现了runnable接口的SubThread实例，将其传入Thread的构造函数中，接着调用Thread的start()方法。 多线程的用法3： Thread构造方法传入Runnable匿名类如果你不想专门定义一个类去实现Runnable接口，可以用匿名类的方式 12345678new Thread(new Runnable(){ @Override public void run(){ //处理具体的逻辑 }}).start();","link":"/2018/10/22/Java多线程基础的副本/"},{"title":"Linux缺少libpng12-0依赖的解决方法","text":"在安装SP_Flash_Tool时命令行出现如下提示，导致程序无法正常使用 12/SP_Flash_Tool/flash_tool: error while loading shared libraries: libpng12.so.0: cannot open shared object file: No such file or directory 解决步骤经查stackoverflow,原因是因为 It says there is not libpng on your system. I’m not familiar with Kali, but if this thread is correct, you’ll have to compile from source 即系统里没有libpng这个依赖 具体解决步骤如下： 从debian下载libpng 命令行执行安装 1dpkg -i libpng12-0_1.2.50-2+deb8u2_amd64.deb 1apt-get install -f 运行SP_Flash_Tool 1sudo /SP_Flash_Tool/flash_tool","link":"/2018/09/21/Linux缺少libpng12-0依赖的解决方法/"},{"title":"Linux缺少libpng12-0依赖的解决方法","text":"在安装SP_Flash_Tool时命令行出现如下提示，导致程序无法正常使用 12/SP_Flash_Tool/flash_tool: error while loading shared libraries: libpng12.so.0: cannot open shared object file: No such file or directory 解决步骤经查stackoverflow,原因是因为 It says there is not libpng on your system. I’m not familiar with Kali, but if this thread is correct, you’ll have to compile from source 即系统里没有libpng这个依赖 具体解决步骤如下： 从debian下载libpng 命令行执行安装 1dpkg -i libpng12-0_1.2.50-2+deb8u2_amd64.deb 1apt-get install -f 运行SP_Flash_Tool 1sudo /SP_Flash_Tool/flash_tool","link":"/2018/09/21/Linux缺少libpng12-0依赖的解决方法的副本/"},{"title":"RxJava2学习笔记","text":"草率地看了些许RxJava的文章，自己的理解是，RxJava结合观察者模式实现异步操作，在观察者(Observable)流中处理一些事务，当流中一个事物完成后，会通知被观察者(Observer)，使其对结果再进行处理。 工程引用在app的build.gradle中添加依赖: 1234//添加RxJava2依赖implementation 'io.reactivex.rxjava2:rxjava:2.2.3'//添加RxAndroid依赖implementation 'io.reactivex.rxjava2:rxandroid:2.1.0' 核心概念与RxJava1相同，RxJava2的核心概念依旧是 Observable Observer Subscribe Affair 并多了两个新的概念 Subscriber(一种新的观察者：订阅者) Flowable（一种新的被观察者） 使用方式 Observable的创建 RxJava的多样性体现在被观察者的创建方式上。 create()方法 创建方式： 123456789Observable&lt;String&gt; observable = Observable.create(new ObservableOnSubscribe&lt;String&gt;() { @Override public void subscribe(ObservableEmitter&lt;String&gt; emitter) throws Exception { //执行一些其他操作 //............. //执行完毕，触发回调，通知观察者 emitter.onNext(\"我来发射数据\"); } }); just()方法 创建方式： 1Observable&lt;String&gt; observable = Observable.just(\"data\"); fromIterable()方法 创建方式： 12345List&lt;String&gt; list = new ArrayList&lt;String&gt;(); for(int i =0;i&lt;10;i++){ list.add(\"Hello\"+i); }Observable&lt;String&gt; observable = Observable.fromIterable((Iterable&lt;String&gt;) list); 注意：Collection接口是Iterable接口的子接口，所以所有Collection接口的实现类都可以作为Iterable对象直接传入fromIterable()方法。 defer()方式 创建方式： 123456Observable&lt;String&gt; observable = Observable.defer(new Callable&lt;ObservableSource&lt;? extends String&gt;&gt;() { @Override public ObservableSource&lt;? extends String&gt; call() throws Exception { return Observable.just(\"hello\"); } }); interval()方式 创建方式： 1Observable&lt;String&gt; observable = Observable.interval(2, TimeUnit.SECONDS); range( )方式 创建方式： 1Observable&lt;Integer&gt; observable = Observable.range(1,20); timer( )方式 创建方式： 1Observable&lt;Integer&gt; observable = Observable.timer(2, TimeUnit.SECONDS); repeat( )方式 创建方式： 1Observable&lt;Integer&gt; observable = Observable.just(123).repeat(); Observer的创建 创建方式: 12345678910111213141516171819202122Observer&lt;String&gt; observer = new Observer&lt;String&gt;() { @Override public void onSubscribe(Disposable d) { } @Override //观察者接收到通知,进行相关操作 public void onNext(String data) { System.out.println(\"data is: \"+data); } @Override public void onError(Throwable e) { } @Override public void onComplete() { } }; 实现订阅 创建方式： 1observable.subscribe(observer); 操作符 map() 将原来的Observable对象转换成另一个Observable对象 123456Observable.range(0, 100).map(new Function&lt;Integer, String&gt;() { @Override public String apply(Integer integer) throws Exception { return \"num \"+integer; } }); flatMap() flatMap()可以将集合等数据转换成Obseravable对象，并把数据转换成Observer想要的数据形式。 1234567891011121314151617181920//生成一个listList&lt;String&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 100; i++) { list.add(\"number \" + i); }//用flatMap()将list转化为一个Observable对象Observable.just(list) .flatMap(new Function&lt;List&lt;String&gt;, ObservableSource&lt;?&gt;&gt;() { @Override public ObservableSource&lt;?&gt; apply(List&lt;String&gt; strings) throws Exception { return Observable.fromIterable(strings); } }) .subscribe(new Consumer&lt;Object&gt;() { @Override public void accept(Object o) throws Exception { Log.d(TAG, (String) o); } }); filter() 根据自己增加的过滤条件，过滤出自己需要的数据加入到新的Observable对象中。 1234567891011121314151617181920Observable.just(list).flatMap(new Function&lt;List&lt;String&gt;, ObservableSource&lt;?&gt;&gt;() { @Override public ObservableSource&lt;?&gt; apply(List&lt;String&gt; strings) throws Exception { return Observable.fromIterable(strings); } }).filter(new Predicate&lt;Object&gt;() { @Override public boolean test(Object s) throws Exception { String newStr = (String) s; if (newStr.charAt(5) - '0' &gt; 5) { return true; } return false; } }).subscribe(new Consumer&lt;Object&gt;() { @Override public void accept(Object o) throws Exception { System.out.println((String)o); } }); take() 输出最多指定数量的结果 doOnNext() 允许我们在每次输出一个元素之前做一些额外的事情。 12345678910111213141516Observable.just(list).flatMap(new Function&lt;List&lt;String&gt;, ObservableSource&lt;?&gt;&gt;() { @Override public ObservableSource&lt;?&gt; apply(List&lt;String&gt; strings) throws Exception { return Observable.fromIterable(strings); } }).take(5).doOnNext(new Consumer&lt;Object&gt;() { @Override public void accept(Object o) throws Exception { System.out.println(\"准备工作\"); } }).subscribe(new Consumer&lt;Object&gt;() { @Override public void accept(Object s) throws Exception { System.out.println((String)s); } });","link":"/2018/11/21/RxJava2学习笔记/"},{"title":"RxJava2学习笔记","text":"草率地看了些许RxJava的文章，自己的理解是，RxJava结合观察者模式实现异步操作，在观察者(Observable)流中处理一些事务，当流中一个事物完成后，会通知被观察者(Observer)，使其对结果再进行处理。 工程引用在app的build.gradle中添加依赖: 1234//添加RxJava2依赖implementation 'io.reactivex.rxjava2:rxjava:2.2.3'//添加RxAndroid依赖implementation 'io.reactivex.rxjava2:rxandroid:2.1.0' 核心概念与RxJava1相同，RxJava2的核心概念依旧是 Observable Observer Subscribe Affair 并多了两个新的概念 Subscriber(一种新的观察者：订阅者) Flowable（一种新的被观察者） 使用方式 Observable的创建 RxJava的多样性体现在被观察者的创建方式上。 create()方法 创建方式： 123456789Observable&lt;String&gt; observable = Observable.create(new ObservableOnSubscribe&lt;String&gt;() { @Override public void subscribe(ObservableEmitter&lt;String&gt; emitter) throws Exception { //执行一些其他操作 //............. //执行完毕，触发回调，通知观察者 emitter.onNext(\"我来发射数据\"); } }); just()方法 创建方式： 1Observable&lt;String&gt; observable = Observable.just(\"data\"); fromIterable()方法 创建方式： 12345List&lt;String&gt; list = new ArrayList&lt;String&gt;(); for(int i =0;i&lt;10;i++){ list.add(\"Hello\"+i); }Observable&lt;String&gt; observable = Observable.fromIterable((Iterable&lt;String&gt;) list); 注意：Collection接口是Iterable接口的子接口，所以所有Collection接口的实现类都可以作为Iterable对象直接传入fromIterable()方法。 defer()方式 创建方式： 123456Observable&lt;String&gt; observable = Observable.defer(new Callable&lt;ObservableSource&lt;? extends String&gt;&gt;() { @Override public ObservableSource&lt;? extends String&gt; call() throws Exception { return Observable.just(\"hello\"); } }); interval()方式 创建方式： 1Observable&lt;String&gt; observable = Observable.interval(2, TimeUnit.SECONDS); range( )方式 创建方式： 1Observable&lt;Integer&gt; observable = Observable.range(1,20); timer( )方式 创建方式： 1Observable&lt;Integer&gt; observable = Observable.timer(2, TimeUnit.SECONDS); repeat( )方式 创建方式： 1Observable&lt;Integer&gt; observable = Observable.just(123).repeat(); Observer的创建 创建方式: 12345678910111213141516171819202122Observer&lt;String&gt; observer = new Observer&lt;String&gt;() { @Override public void onSubscribe(Disposable d) { } @Override //观察者接收到通知,进行相关操作 public void onNext(String data) { System.out.println(\"data is: \"+data); } @Override public void onError(Throwable e) { } @Override public void onComplete() { } }; 实现订阅 创建方式： 1observable.subscribe(observer); 操作符 map() 将原来的Observable对象转换成另一个Observable对象 123456Observable.range(0, 100).map(new Function&lt;Integer, String&gt;() { @Override public String apply(Integer integer) throws Exception { return \"num \"+integer; } }); flatMap() flatMap()可以将集合等数据转换成Obseravable对象，并把数据转换成Observer想要的数据形式。 1234567891011121314151617181920//生成一个listList&lt;String&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 100; i++) { list.add(\"number \" + i); }//用flatMap()将list转化为一个Observable对象Observable.just(list) .flatMap(new Function&lt;List&lt;String&gt;, ObservableSource&lt;?&gt;&gt;() { @Override public ObservableSource&lt;?&gt; apply(List&lt;String&gt; strings) throws Exception { return Observable.fromIterable(strings); } }) .subscribe(new Consumer&lt;Object&gt;() { @Override public void accept(Object o) throws Exception { Log.d(TAG, (String) o); } }); filter() 根据自己增加的过滤条件，过滤出自己需要的数据加入到新的Observable对象中。 1234567891011121314151617181920Observable.just(list).flatMap(new Function&lt;List&lt;String&gt;, ObservableSource&lt;?&gt;&gt;() { @Override public ObservableSource&lt;?&gt; apply(List&lt;String&gt; strings) throws Exception { return Observable.fromIterable(strings); } }).filter(new Predicate&lt;Object&gt;() { @Override public boolean test(Object s) throws Exception { String newStr = (String) s; if (newStr.charAt(5) - '0' &gt; 5) { return true; } return false; } }).subscribe(new Consumer&lt;Object&gt;() { @Override public void accept(Object o) throws Exception { System.out.println((String)o); } }); take() 输出最多指定数量的结果 doOnNext() 允许我们在每次输出一个元素之前做一些额外的事情。 12345678910111213141516Observable.just(list).flatMap(new Function&lt;List&lt;String&gt;, ObservableSource&lt;?&gt;&gt;() { @Override public ObservableSource&lt;?&gt; apply(List&lt;String&gt; strings) throws Exception { return Observable.fromIterable(strings); } }).take(5).doOnNext(new Consumer&lt;Object&gt;() { @Override public void accept(Object o) throws Exception { System.out.println(\"准备工作\"); } }).subscribe(new Consumer&lt;Object&gt;() { @Override public void accept(Object s) throws Exception { System.out.println((String)s); } });","link":"/2018/11/21/RxJava2学习笔记的副本/"},{"title":"Ubuntu系统下adb检测不到设备的处理方案","text":"Ubuntu18.04环境下adb经常连接不上安卓设备，或者连接上后很快断开。 ![此时usb接口已经连接了安卓设备,adb却检测不到](/images/35.png) 原因分析经查阅文档，该问题的原因为adb的特征识别码中未保存我们车机的相关信息，导致usb口能识别设备，但adb无法识别改设备。 解决方案须手动保存相应的设备信息 查看usb设备 断开安卓设备与PC的usb连接，使用命令lsusb查看usb设备，如图： 重新将安卓设备与PC的usb接口连接，再次使用lsusb查看usb设备，如图： 可以发现usb接口插入安卓设备后，多出了两个bus： 其中0424:494c和0424:4715就是安卓设备的特征识别码,0424为VendorId,494c和4715为ProductId。 将特征识别码添加至ADB白名单内 在/etc/udev/rules.d/路径下新建70-Android.rules文件 1sudo gedit /etc/udev/rules.d/70-android.rules 在文件中添加安卓设备的特征识别码,如下所示 12SUBSYSTEM==\"usb\", ATTR{idVendor}==\"0424\",ATTRS{idProduct}==\"494c\",MODE=\"0666\"SUBSYSTEM==\"usb\", ATTR{idVendor}==\"0424\",ATTRS{idProduct}==\"4715\",MODE=\"0666\" 保存并退出该文件，如下图所示 给70-Android.rules文件添加权限 1sudo chmod 777 '/etc/udev/rules.d/70-Android.rules' 重启系统的udev服务 1sudo service udev restart 关闭adb服务 1adb kill-server 重新使用adb检测安卓设备 1adb devices 可以看到已经成功检测出安卓设备 如果还是检测不到设备，则执行如下命令,将设备的VendorId写入adb_usb.ini文件中 1echo echo \"0x0424\" &gt;~/.android/adb_usb.ini 再次出现该问题的解决方案只需关闭adb服务后再打开adb检测安卓设备 12adb kill-serveradb devices","link":"/2019/02/13/Ubuntu系统下adb检测不到设备的处理方案/"},{"title":"Ubuntu系统下adb检测不到设备的处理方案","text":"Ubuntu18.04环境下adb经常连接不上安卓设备，或者连接上后很快断开。 ![此时usb接口已经连接了安卓设备,adb却检测不到](/images/35.png) 原因分析经查阅文档，该问题的原因为adb的特征识别码中未保存我们车机的相关信息，导致usb口能识别设备，但adb无法识别改设备。 解决方案须手动保存相应的设备信息 查看usb设备 断开安卓设备与PC的usb连接，使用命令lsusb查看usb设备，如图： 重新将安卓设备与PC的usb接口连接，再次使用lsusb查看usb设备，如图： 可以发现usb接口插入安卓设备后，多出了两个bus： 其中0424:494c和0424:4715就是安卓设备的特征识别码,0424为VendorId,494c和4715为ProductId。 将特征识别码添加至ADB白名单内 在/etc/udev/rules.d/路径下新建70-Android.rules文件 1sudo gedit /etc/udev/rules.d/70-android.rules 在文件中添加安卓设备的特征识别码,如下所示 12SUBSYSTEM==\"usb\", ATTR{idVendor}==\"0424\",ATTRS{idProduct}==\"494c\",MODE=\"0666\"SUBSYSTEM==\"usb\", ATTR{idVendor}==\"0424\",ATTRS{idProduct}==\"4715\",MODE=\"0666\" 保存并退出该文件，如下图所示 给70-Android.rules文件添加权限 1sudo chmod 777 '/etc/udev/rules.d/70-Android.rules' 重启系统的udev服务 1sudo service udev restart 关闭adb服务 1adb kill-server 重新使用adb检测安卓设备 1adb devices 可以看到已经成功检测出安卓设备 如果还是检测不到设备，则执行如下命令,将设备的VendorId写入adb_usb.ini文件中 1echo echo \"0x0424\" &gt;~/.android/adb_usb.ini 再次出现该问题的解决方案只需关闭adb服务后再打开adb检测安卓设备 12adb kill-serveradb devices","link":"/2019/02/13/Ubuntu系统下adb检测不到设备的处理方案的副本/"},{"title":"《Java编程思想》读书笔记(序章)","text":"绪论 程序设计是对复杂性的管理 待解决问题的复杂性 用来解决该问题的工具的复杂性 在足够多的人的相互联系之上，下一次变革将是一种全球意识的形成 Arts&amp;Crafts运动始于世纪之交，在1900至1920年间达到巅峰，强调简洁设计，回归自然是整个运动的核心，注重手工制造集推崇个性化设计。 上帝赋予人类说话的能力，而语言又创造了思想，思想是人类对宇宙的量度 真实世界在很大程度上是不知不觉的基于群体的语言习惯形成的 你需要在头脑里创建一个模型，以加强你对这种语言的深入理解 Code Standard标识符(方法，变量和类名)排为粗体 大部分的关键字为粗体，但不包括频繁使用的关键字","link":"/2018/09/04/《Java编程思想》读书笔记(序章)/"},{"title":"《Java编程思想》读书笔记(序章)","text":"绪论 程序设计是对复杂性的管理 待解决问题的复杂性 用来解决该问题的工具的复杂性 在足够多的人的相互联系之上，下一次变革将是一种全球意识的形成 Arts&amp;Crafts运动始于世纪之交，在1900至1920年间达到巅峰，强调简洁设计，回归自然是整个运动的核心，注重手工制造集推崇个性化设计。 上帝赋予人类说话的能力，而语言又创造了思想，思想是人类对宇宙的量度 真实世界在很大程度上是不知不觉的基于群体的语言习惯形成的 你需要在头脑里创建一个模型，以加强你对这种语言的深入理解 Code Standard标识符(方法，变量和类名)排为粗体 大部分的关键字为粗体，但不包括频繁使用的关键字","link":"/2018/09/04/《Java编程思想》读书笔记(序章)的副本/"},{"title":"《Java编程思想》读书笔记(第一章)","text":"对象导论 编程语言始于对机器的模仿，但并非机器那么简单，它是一种不同类型的表达媒体 What is Object-oriented Programming? 人们所能够解决的问题的复杂性直接取决于抽象的类型和质量 解空间：你对问题建模的地方，如机器 问题空间：问题存在的地方 The definition of Object 问题空间的元素及其在解空间的表示 对象具有状态，行为，标识 面向对象的设计方式 万物皆对象 程序是对象的集合 每个对象都有自己的由其他对象所构成的存储 每个对象都拥有其类型 某一特定类型的所有对象都可以接收同样的信息 每个对象在内存中都有一个唯一的地址创建对象的方式 定义这个对象的引用(reference) 调用new方法创建新对象 用统一建模语言表示类 UML即unified modelling language 每个类都用一个方框表示，类名在方框的顶部，你所关心的任何成员变量都描述在方框的中间部分，方法在方框的底部 通常，只有类名和公共方法被示于UML设计图中 如果只对类型感兴趣，那么方框的底部也不需要给出","link":"/2018/09/05/《Java编程思想》读书笔记(第一章)/"},{"title":"《Java编程思想》读书笔记(第一章)","text":"对象导论 编程语言始于对机器的模仿，但并非机器那么简单，它是一种不同类型的表达媒体 What is Object-oriented Programming? 人们所能够解决的问题的复杂性直接取决于抽象的类型和质量 解空间：你对问题建模的地方，如机器 问题空间：问题存在的地方 The definition of Object 问题空间的元素及其在解空间的表示 对象具有状态，行为，标识 面向对象的设计方式 万物皆对象 程序是对象的集合 每个对象都有自己的由其他对象所构成的存储 每个对象都拥有其类型 某一特定类型的所有对象都可以接收同样的信息 每个对象在内存中都有一个唯一的地址创建对象的方式 定义这个对象的引用(reference) 调用new方法创建新对象 用统一建模语言表示类 UML即unified modelling language 每个类都用一个方框表示，类名在方框的顶部，你所关心的任何成员变量都描述在方框的中间部分，方法在方框的底部 通常，只有类名和公共方法被示于UML设计图中 如果只对类型感兴趣，那么方框的底部也不需要给出","link":"/2018/09/05/《Java编程思想》读书笔记(第一章)的副本/"},{"title":"《Java编程思想》读书笔记(第七章)","text":"三种代码重用机制：组合，继承，代理 每一个非基本类型的对象都有一个toString()方法，而且当编译器需要一个String而你却只有一个对象时，该方法就会调用 java使用super关键词来表示超类，表达式super.method()将调用基类版本的scrub() java会自动在导出类的构造器中插入对基类构造器的调用 使用代理时可以拥有更多的控制力，我们可以选择提供成员对象中的方法中的子集 12345678910111213141516171819202122232425262728class SpaceShipControl{ void forward(int speed); void backward(int speed); void left(int speed); void right(int speed);}public class SpaceShipDetegent{ private String name; private SpaceShipControl ssp=new SpaceShipControl(); public SpaceShipDetegent(String name){ this.name=name; } public void backward(int velocity){ ssp.backward(velocity); } public void forward(int velocity){ ssp.backward(velocity); } public static void main(String[] args){ SpaceShipDetegent ssd=new SpaceShipDetegent(\"NASA Protector\"); ssd.backward(100); }} 无论try块是怎样退出的,保护区后的finally子句中的代码块总是要被执行的 将子类引用转化为基类引用的动作，称之为upcasting向上转型 static强调只有一份，final说明它是一个常量 final参数final可以修饰数据，方法，类 java允许在参数列表中以声明的方式将参数指明为final，意味着你无法在方法中更改参数引用所指向的对象，你可以读参数，但却无法修改参数，这一特性主要用来向匿名内部类传递数据 final方法使用的原因： 锁定方法，防止继承类修改它的含义，禁止子类覆盖该方法 性能优化 类中的private方法都隐式的指定为是final的，因为子类无法取用private方法，所以也就无法覆盖它 override覆盖只在某方法是基类的接口的一部分时候才有效，如果基类的方法是private修饰，它就不是基类接口的一部分 final修饰类时，表示该类不可被继承。final类中的所有方法都被隐式指定为final的 类的代码在初次使用的时候才加载","link":"/2019/04/09/《Java编程思想》读书笔记(第七章)/"},{"title":"《Java编程思想》读书笔记(第七章)","text":"三种代码重用机制：组合，继承，代理 每一个非基本类型的对象都有一个toString()方法，而且当编译器需要一个String而你却只有一个对象时，该方法就会调用 java使用super关键词来表示超类，表达式super.method()将调用基类版本的scrub() java会自动在导出类的构造器中插入对基类构造器的调用 使用代理时可以拥有更多的控制力，我们可以选择提供成员对象中的方法中的子集 12345678910111213141516171819202122232425262728class SpaceShipControl{ void forward(int speed); void backward(int speed); void left(int speed); void right(int speed);}public class SpaceShipDetegent{ private String name; private SpaceShipControl ssp=new SpaceShipControl(); public SpaceShipDetegent(String name){ this.name=name; } public void backward(int velocity){ ssp.backward(velocity); } public void forward(int velocity){ ssp.backward(velocity); } public static void main(String[] args){ SpaceShipDetegent ssd=new SpaceShipDetegent(\"NASA Protector\"); ssd.backward(100); }} 无论try块是怎样退出的,保护区后的finally子句中的代码块总是要被执行的 将子类引用转化为基类引用的动作，称之为upcasting向上转型 static强调只有一份，final说明它是一个常量 final参数final可以修饰数据，方法，类 java允许在参数列表中以声明的方式将参数指明为final，意味着你无法在方法中更改参数引用所指向的对象，你可以读参数，但却无法修改参数，这一特性主要用来向匿名内部类传递数据 final方法使用的原因： 锁定方法，防止继承类修改它的含义，禁止子类覆盖该方法 性能优化 类中的private方法都隐式的指定为是final的，因为子类无法取用private方法，所以也就无法覆盖它 override覆盖只在某方法是基类的接口的一部分时候才有效，如果基类的方法是private修饰，它就不是基类接口的一部分 final修饰类时，表示该类不可被继承。final类中的所有方法都被隐式指定为final的 类的代码在初次使用的时候才加载","link":"/2019/04/09/《Java编程思想》读书笔记(第七章)的副本/"},{"title":"《Java编程思想》读书笔记(第三章)","text":"如果想通过“加号”连接字串（使用 Java 的早期版本），请务必保证第一个元素是字串（或加上引号的一系列字符，编译能将其识别成一个字串）。 十六进制（Base 16）——它适用于所有整数数据类型——用一个前置的 0x 或 0X 指示。并在后面跟随采用大写或小写形式的0-9 以及a-f。 八进制（Base 8）是用数字中的一个前置0 以及0-7 的数位指示的。 在 C，C++或者Java 中，对二进制数字没有相应的“字面”表示方法。 指数总是采用一种我们认为很不直观的记号方法：1.39e-47f。它真正的含义是“1.39×10 的-47 次方”。 注意如果编译器能够正确地识别类型，就不必使用尾随字符（long n3 = 200）。 编译器通常会将指数作为双精度数（double）处理，所以假如没有这个尾随的 f，就会收到一条出错提示，告诉我们须用一个“造型”将 double 转换成 float。 1float f4 = 1e-47f; //10 的幂数 运算符优先顺序： 一元运算符 &gt; 算术运算符和移位运算符 &gt; 关系运算符 &gt; 逻辑运算符和按位运算符 &gt; 条件运算符（三元） &gt; 赋值运算符（包括复合赋值，如*=） Java 使用了 C 的全部控制语句。 for 循环在第一次反复之前要进行初始化。随后，它会进行条件测试，而且在每一次反复的时候，进行某种形式的“步进”（Stepping）。for 循环的形式如下： 12for(初始表达式; 布尔表达式; 步进)语句 以于象 C 这样传统的程序化语言，要求所有变量都在一个块的开头定义。所以在编译器创建一个块的时候，它可以为那些变量分配空间。而在 Java 和C++中，则可在整个块的范围内分散变量声明，在真正需要的地方才加以定义。这样便可形成更自然的编码风格，也更易理解。 可在for 语句里定义多个变量，但它们必须具有同样的类型： 1234for(int i = 0, j = 1; i &lt; 10 &amp;&amp; j != 11; i++, j++) /* body of for loop */; 其中，for 语句内的 int 定义同时覆盖了i 和 j。只有 for 循环才具备在控制表达式里定义变量的能力。对于其他任何条件或循环语句，都不可采用这种方法。 无限循环的第二种形式是for(;;)。编译器将 while(true)与 for(;;)看作同一回事。所以具体选用哪个取决于自己的编程习惯。 在Java 里唯一需要用到标签的地方就是拥有嵌套循环，而且想中断或继续多个嵌套级别的时候。","link":"/2018/09/06/《Java编程思想》读书笔记(第三章)/"},{"title":"《Java编程思想》读书笔记(第三章)","text":"如果想通过“加号”连接字串（使用 Java 的早期版本），请务必保证第一个元素是字串（或加上引号的一系列字符，编译能将其识别成一个字串）。 十六进制（Base 16）——它适用于所有整数数据类型——用一个前置的 0x 或 0X 指示。并在后面跟随采用大写或小写形式的0-9 以及a-f。 八进制（Base 8）是用数字中的一个前置0 以及0-7 的数位指示的。 在 C，C++或者Java 中，对二进制数字没有相应的“字面”表示方法。 指数总是采用一种我们认为很不直观的记号方法：1.39e-47f。它真正的含义是“1.39×10 的-47 次方”。 注意如果编译器能够正确地识别类型，就不必使用尾随字符（long n3 = 200）。 编译器通常会将指数作为双精度数（double）处理，所以假如没有这个尾随的 f，就会收到一条出错提示，告诉我们须用一个“造型”将 double 转换成 float。 1float f4 = 1e-47f; //10 的幂数 运算符优先顺序： 一元运算符 &gt; 算术运算符和移位运算符 &gt; 关系运算符 &gt; 逻辑运算符和按位运算符 &gt; 条件运算符（三元） &gt; 赋值运算符（包括复合赋值，如*=） Java 使用了 C 的全部控制语句。 for 循环在第一次反复之前要进行初始化。随后，它会进行条件测试，而且在每一次反复的时候，进行某种形式的“步进”（Stepping）。for 循环的形式如下： 12for(初始表达式; 布尔表达式; 步进)语句 以于象 C 这样传统的程序化语言，要求所有变量都在一个块的开头定义。所以在编译器创建一个块的时候，它可以为那些变量分配空间。而在 Java 和C++中，则可在整个块的范围内分散变量声明，在真正需要的地方才加以定义。这样便可形成更自然的编码风格，也更易理解。 可在for 语句里定义多个变量，但它们必须具有同样的类型： 1234for(int i = 0, j = 1; i &lt; 10 &amp;&amp; j != 11; i++, j++) /* body of for loop */; 其中，for 语句内的 int 定义同时覆盖了i 和 j。只有 for 循环才具备在控制表达式里定义变量的能力。对于其他任何条件或循环语句，都不可采用这种方法。 无限循环的第二种形式是for(;;)。编译器将 while(true)与 for(;;)看作同一回事。所以具体选用哪个取决于自己的编程习惯。 在Java 里唯一需要用到标签的地方就是拥有嵌套循环，而且想中断或继续多个嵌套级别的时候。","link":"/2018/09/06/《Java编程思想》读书笔记(第三章)的副本/"},{"title":"《Java编程思想》读书笔记(第九章)","text":"接口和内部类为我们提供了一种将接口与实现分离的更加结构化的方法 包含抽象方法的类叫做抽象类，抽象方法只有声明而没有方法体 如果从一个抽象类继承，并且想创建该新类的对象，那么就必须为基类中所有的抽象方法提供方法定义。如果不这么做，那么导出类也是抽象类，且编译器会强制我们用abstract来限定这个类","link":"/2019/04/16/《Java编程思想》读书笔记(第九章)/"},{"title":"《Java编程思想》读书笔记(第九章)","text":"接口和内部类为我们提供了一种将接口与实现分离的更加结构化的方法 包含抽象方法的类叫做抽象类，抽象方法只有声明而没有方法体 如果从一个抽象类继承，并且想创建该新类的对象，那么就必须为基类中所有的抽象方法提供方法定义。如果不这么做，那么导出类也是抽象类，且编译器会强制我们用abstract来限定这个类","link":"/2019/04/16/《Java编程思想》读书笔记(第九章)的副本/"},{"title":"《Java编程思想》读书笔记(第五章)","text":"java提供构造器，确保每个对象都会得到初始化 构造器采用与类相同的名称 创建对象时，先为对象分配足够的存储空间，再调用相应的构造器 由于构造器的名称必须与类完全相同，所以每个方法首字母小写的编码风格并不适用于构造器 不接受任何参数的构造器叫做默认构造器，javaDoc中经常使用术语“无参构造器” 如果一个类中只有一个构造器，那么编译器将不会允许你以其他方式创建这个类 构造器是一种特殊类型的方法，不仅没有返回值，也不会返回任何东西 每一个重载的方法都必须有一个独一无二的参数类型列表，参数顺序不同也足以区分两个方法 基本类型能从一个较小的类型自动提升至一个较大的类型 如果传入的实际参数大于重载方法声明的形式参数，就需要通过类型转换来执行窄化转换 不能通过返回值来区分重载方法 为了能用简便的面向对象的语法来编写代码，即“发送消息给对象”，编译器暗自把所操作对象的引用作为第一个参数传递给了方法 this关键字只能在方法内部使用，表示对“调用方法的那个对象”的引用。 如果在方法内部调用同一个类的另一个方法，就不必使用this，因为当前方法中this引用会自动应用于同一个类的其他方法 当方法需要返回当前对象的引用时，可以在return语句中写return this 在构造器中调用构造器，需要用到this参数，且必须将构造器调用置于最起始处 使用this.s来代表数据成员，与参数s区别开 static方法就是没有this的方法，在static方法内部不能调用非静态方法,可以在没有创建任何对象的前提下，仅仅通过类本身来调用static方法。 对象可能不被垃圾回收 垃圾回收并不等于析构 垃圾回收只与内存有关 System.gc()用于强制进行终结动作 在类的内部，变量定义的先后顺序决定了初始化的顺序，即使变量定义散布于方法定义之间，他们仍然会在任何方法（包括构造器）被调用前得到初始化 无论创建多少个对象，静态数据都只占用一份存储空间 数组只是相同类型的，用一个标识符名称封装到一起的一个对象序列或基本类型序列 定义一个数组，只要在类型名后面加上一对方括号 可以用特殊初始化表达式来定义数组：int[] a1={1,2,3,4,5} 一个数组赋值给另一个数组，其实只是复制了一个引用 所有数组都有一个固有成员length,通过它可以获知数组内包含多少个元素 java数组和C与C++类似从第0个元素开始，所以能使用的最大下标数为length-1 Array.toString()方法属于java.util标准类库，可产生一维数组的可打印版本 打印对象的默认行为就是打印类的名字和对象的地址 java提供可变参数列表，其写法为Object... arrays 可变参数列表使重载过程变得复杂，可以在参数中填加一个不可变参数来避免该问题 枚举类型的ordinal()方法输出特定enum常量的声明顺序，Static values()方法按照enum常量的声明顺序，产生这些常量构成的数组 enum可以在switch语句中使用","link":"/2019/04/09/《Java编程思想》读书笔记(第五章)/"},{"title":"《Java编程思想》读书笔记(第五章)","text":"java提供构造器，确保每个对象都会得到初始化 构造器采用与类相同的名称 创建对象时，先为对象分配足够的存储空间，再调用相应的构造器 由于构造器的名称必须与类完全相同，所以每个方法首字母小写的编码风格并不适用于构造器 不接受任何参数的构造器叫做默认构造器，javaDoc中经常使用术语“无参构造器” 如果一个类中只有一个构造器，那么编译器将不会允许你以其他方式创建这个类 构造器是一种特殊类型的方法，不仅没有返回值，也不会返回任何东西 每一个重载的方法都必须有一个独一无二的参数类型列表，参数顺序不同也足以区分两个方法 基本类型能从一个较小的类型自动提升至一个较大的类型 如果传入的实际参数大于重载方法声明的形式参数，就需要通过类型转换来执行窄化转换 不能通过返回值来区分重载方法 为了能用简便的面向对象的语法来编写代码，即“发送消息给对象”，编译器暗自把所操作对象的引用作为第一个参数传递给了方法 this关键字只能在方法内部使用，表示对“调用方法的那个对象”的引用。 如果在方法内部调用同一个类的另一个方法，就不必使用this，因为当前方法中this引用会自动应用于同一个类的其他方法 当方法需要返回当前对象的引用时，可以在return语句中写return this 在构造器中调用构造器，需要用到this参数，且必须将构造器调用置于最起始处 使用this.s来代表数据成员，与参数s区别开 static方法就是没有this的方法，在static方法内部不能调用非静态方法,可以在没有创建任何对象的前提下，仅仅通过类本身来调用static方法。 对象可能不被垃圾回收 垃圾回收并不等于析构 垃圾回收只与内存有关 System.gc()用于强制进行终结动作 在类的内部，变量定义的先后顺序决定了初始化的顺序，即使变量定义散布于方法定义之间，他们仍然会在任何方法（包括构造器）被调用前得到初始化 无论创建多少个对象，静态数据都只占用一份存储空间 数组只是相同类型的，用一个标识符名称封装到一起的一个对象序列或基本类型序列 定义一个数组，只要在类型名后面加上一对方括号 可以用特殊初始化表达式来定义数组：int[] a1={1,2,3,4,5} 一个数组赋值给另一个数组，其实只是复制了一个引用 所有数组都有一个固有成员length,通过它可以获知数组内包含多少个元素 java数组和C与C++类似从第0个元素开始，所以能使用的最大下标数为length-1 Array.toString()方法属于java.util标准类库，可产生一维数组的可打印版本 打印对象的默认行为就是打印类的名字和对象的地址 java提供可变参数列表，其写法为Object... arrays 可变参数列表使重载过程变得复杂，可以在参数中填加一个不可变参数来避免该问题 枚举类型的ordinal()方法输出特定enum常量的声明顺序，Static values()方法按照enum常量的声明顺序，产生这些常量构成的数组 enum可以在switch语句中使用","link":"/2019/04/09/《Java编程思想》读书笔记(第五章)的副本/"},{"title":"《Java编程思想》读书笔记(第八章)","text":"把某个对象的引用视为对其基类类型的引用的做法被称作upcasting向上转型 将一个方法调用同一个方法主体关联起来被称作绑定，若在程序执行前进行绑定叫做前期绑定 java中除了static和final方法之外，其他所有的方法都是后期绑定 非private方法才能被覆盖 静态对象是与类，而非与单个对象相关联的 构造器的调用顺序： 调用基类构造器，这个步骤会不断的递归下去，首先是构造这种层次结构的根，然后是下一层导出类，等等，直到最底层的导出类 按声明顺序调用成员的初始化方法 调用导出类构造器的主体 协变返回类型标识在导出类的被覆盖方法可以返回基类方法的返回类型的某种导出类型 引用可以在运行时与另外一个不同的对象重新绑定起来","link":"/2019/04/15/《Java编程思想》读书笔记(第八章)/"},{"title":"《Java编程思想》读书笔记(第八章)","text":"把某个对象的引用视为对其基类类型的引用的做法被称作upcasting向上转型 将一个方法调用同一个方法主体关联起来被称作绑定，若在程序执行前进行绑定叫做前期绑定 java中除了static和final方法之外，其他所有的方法都是后期绑定 非private方法才能被覆盖 静态对象是与类，而非与单个对象相关联的 构造器的调用顺序： 调用基类构造器，这个步骤会不断的递归下去，首先是构造这种层次结构的根，然后是下一层导出类，等等，直到最底层的导出类 按声明顺序调用成员的初始化方法 调用导出类构造器的主体 协变返回类型标识在导出类的被覆盖方法可以返回基类方法的返回类型的某种导出类型 引用可以在运行时与另外一个不同的对象重新绑定起来","link":"/2019/04/15/《Java编程思想》读书笔记(第八章)的副本/"},{"title":"《Java编程思想》读书笔记(第六章)","text":"重构即重写代码，使它更可读，更易理解，并因此更具可维护性 编写软件的程序员在重构代码时需要考虑如何把变动的事物与保持不变的事物区分开来 类库即library java访问权限控制等级从最大到最小依次为public,protected,包访问权限（没有关键词），private 使用类库的一种方式是用全名来指定，如java.util.ArrayList list = new java.util.ArrayList(); 还可以使用import关键字 123import java.util.ArrayList;ArrayList list = new ArrayList(); 要导入其他类，只需要使用* 文件起始处写package access表示你在声明该编译单元是名为access的类库的一部分 java包的命名规则全部使用小写字母 按照惯例，package名称的第一部分是类的创建者的反顺序Internet域名 package语句必须是文件中第一行非注释程序代码 通过构建自己的类库来减少代码重复量 使用public关键词，意味着public之后紧跟着的成员声明自己对每个人都时可用的 使用private关键词，除了该成员的类之外，其他任何类都无法访问这个成员 使用protect关键词，将基类中成员的访问权限，赋予子类。protect也提供包访问权限 访问权限的控制通常被称为具体实现的隐藏。把数据和方法包装进类中，以及具体实现的隐藏，常共同被称作是封装 类只有两种访问权限：包访问权限或public 如果不希望任何人对某个类具有访问权限，可以把它所有的构造器指定为private,除了一种情况，就是该类的static成员内部可以创建该类对象 方法名称前面的词告知了该方法返回的类型，经常是void，意思是不返回任何东西。但是也可以返回一个对象引用","link":"/2019/04/09/《Java编程思想》读书笔记(第六章)/"},{"title":"《Java编程思想》读书笔记(第六章)","text":"重构即重写代码，使它更可读，更易理解，并因此更具可维护性 编写软件的程序员在重构代码时需要考虑如何把变动的事物与保持不变的事物区分开来 类库即library java访问权限控制等级从最大到最小依次为public,protected,包访问权限（没有关键词），private 使用类库的一种方式是用全名来指定，如java.util.ArrayList list = new java.util.ArrayList(); 还可以使用import关键字 123import java.util.ArrayList;ArrayList list = new ArrayList(); 要导入其他类，只需要使用* 文件起始处写package access表示你在声明该编译单元是名为access的类库的一部分 java包的命名规则全部使用小写字母 按照惯例，package名称的第一部分是类的创建者的反顺序Internet域名 package语句必须是文件中第一行非注释程序代码 通过构建自己的类库来减少代码重复量 使用public关键词，意味着public之后紧跟着的成员声明自己对每个人都时可用的 使用private关键词，除了该成员的类之外，其他任何类都无法访问这个成员 使用protect关键词，将基类中成员的访问权限，赋予子类。protect也提供包访问权限 访问权限的控制通常被称为具体实现的隐藏。把数据和方法包装进类中，以及具体实现的隐藏，常共同被称作是封装 类只有两种访问权限：包访问权限或public 如果不希望任何人对某个类具有访问权限，可以把它所有的构造器指定为private,除了一种情况，就是该类的static成员内部可以创建该类对象 方法名称前面的词告知了该方法返回的类型，经常是void，意思是不返回任何东西。但是也可以返回一个对象引用","link":"/2019/04/09/《Java编程思想》读书笔记(第六章)的副本/"},{"title":"《Java编程思想》读书笔记(第十一章)","text":"数组是保存一组对象的最有效的方式，但是具有固定的尺寸 Java实用类库提供了容器来解决这个问题，其中基本的类型是 List Set Queue Map 这些对象类型也被叫做集合类。Java类库使用了Collection来指代该类库的一个特殊子集，Java编程思想称之为容器。 容器提供了完善的方法来保存对象 不同的容器有不同的特性：Set对于每一个值只保存一个对象，Map是允许你将某一些对象与其他一些对象关联起来的关联数组。 Java容器类可以自动调整自己的尺寸。 范型与类型安全的容器使用ArrayList的基本步骤： 创建一个实例 用add()插入对象 用get()访问对象 访问对象时需要使用索引，就像数组一样，但是不需要方括号 ArrayList还有一个size()方法，查看List中有多少个元素 注解以@符号开头，可以接受参数 @SuppressWarnings(&quot;unchecked&quot;)表示只有有关”不受检查的异常“的警告信息应该被抑制 如果一个类没有显式的声明继承自哪一个类，那么它将自动继承自Object 定义保存特定类型的ArrayList可以声明 ArrayList&lt;Type&gt;，其中尖括号括起来的就是类型参数，它指定了这个容器类可以保存的类型 通过使用范型，就可以在编译期防止将错误类型对象放置到容器中 将元素从指定了范型的容器中取出，不再需要downcasting向下转型，因为容器知道它保存的是什么类型 java对象的默认打印是由Object默认的toString()方法产生的，该方法将打印类名，后面跟随该对象的散列码的无符号十六进制表示（该散列码是通过hashCode()方法产生的） 基本概念java容器类类库的作用是保存对象，划分为两个概念： Collection，一个独立元素的序列 Map，一组成对的键值对对象 映射表允许我们使用另一个对象来查找某个对象，它也被称为关联数组 创建容器的实例应该创建一个具体类的对象，将其转型为对应的接口，在其余代码内都使用这个接口 添加一组元素Arrays.asList()接收一个数组或一个用逗号分隔的元素列表（使用可变参数），并将其转换为List对象 Collections.addAll()方法接收一个Collection对象，以及一个数组或逗号分割的列表，将元素添加到Collection中 可以在Arrays.asList()中插入一条线索，以告诉编译器对于由该方法产生的List类型，实际的目标类型应该是什么，这是显式类型参数说明 1List&lt;Snow&gt; snow4=Arrays.&lt;Snow&gt;asList(new Light(),new Heavy()); ListList接口在Collection的基础上添加了大量的方法，使得可以在List的中间插入和移除元素 List有两种类型： ArrayList擅长于随即访问元素，但是在LIst中间插入和移除元素时较慢 LinkedList可以已代价较低的在List中间进行插入和删除操作，提供了优化的顺序访问，但是在随机访问方面比较慢，但是他的特性集比ArrayList更大 page 223 迭代器java的Iterator只能单向移动，只能用来： 对Collection容器类使用方法iterator()返回一个Iterator，Iterator将准备号返回序列中的第一个元素 使用next()获得序列中的下一个元素 使用hasNext()检查序列中是否还有元素 使用remove()将迭代器新近返回的元素删除 Iterator也支持范型 Iterator能将遍历序列的操作与序列底层的结构分离 迭代器统一了对容器的访问方式 ListIterator通过调用listIterator()方法产生一个指向List开始处的ListIterator; listIterator(n)可以创建一个一开始就指向列表索引为n的元素处的ListIterator LinkedList 方法名 效果 类似方法 效果差别 getFirst()和element() 返回List的第一个元素，而并不移除它,如果List为空，则抛出NoSuchElementException peek() 如果List为空，则返回null removeFirst()和remove() 移除并返回列表的头，在列表为空时抛出NoSuchElementException poll() 在列表为空时返回null Stack栈通常是指后进先出的容器，最后一个压入栈的元素，第一个弹出栈 12345678public class Stack&lt;T&gt;{ private LinkedList&lt;T&gt; storage=new LinkedList&lt;T&gt;(); public void push(T v){storage.addFirst(v);} public T peek(){return storage.getFirst();} public T pop(){return storage.removeFirst();} public boolean isEmpty{return storage.isEmpty();} public String toString(){return storage.toString();}} 类名之后的告诉编译器这将是一个参数化类型，而其中的类型参数，即在类被使用的时候会被实际类型替换的参数，就是T。大体上就是在声明我们在定义一个可以持有T类型对象的Stack SetSet是基于对象的值来确定归属性的 出于速度原因的考虑，HashSet使用了散列 contains()可以测试Set的归属性 MapJava的自动包装机制会将随机生成的int转化为HashMap可以使用的Integer引用 如果key不在Map容器中，get()方法将返回null，否则get()方法将返回与该键相关联的值对象 Map与数组和其他Collection一样很容易扩展到多维，只需要将其值设置为Map keySet()方法产生Map中所有键组合成的Set Queue队列是典型的先进先出的容器(FIFO) offer()方法将一个元素插入队尾，或者返回false peek()和element()都在不移除元素的情况下返回队头 PriorityQueueFIFO先进先出声明的是下一个元素应该是等待时间最长的元素 优先级队列声明的是下一个弹出的元素应该是最需要的元(具有最高的优先级) 优先级队列在Java SE5中被添加 当我们对一个PriorityQueue调用offer()方法来插入一个对象时，这个对象会在队列中被排序，默认顺序是使用对象在队列中的自然顺序，通过提供自己的Comparator来修改这个顺序 优先级队列可以确保调用peek(),poll(),remove()是，获取的元素是队列中优先级最高的元素 Collection和IteratorCollection是描述所有序列容器的共性的根接口 通过针对接口而非具体类型来编写代码，我们的代码就可以应用于更多的对象类型 Collection和Iterator都可以将显示容器内容的实现与底层容器的特定实现解耦 foreach与迭代器foreach语法可以用于数组和任何Collection对象，实现了Iterable接口的类 适配其方法惯用法覆盖Collection对象，添加一个能够产生Iterable对象的方法","link":"/2019/04/16/《Java编程思想》读书笔记(第十一章)/"},{"title":"《Java编程思想》读书笔记(第十一章)","text":"数组是保存一组对象的最有效的方式，但是具有固定的尺寸 Java实用类库提供了容器来解决这个问题，其中基本的类型是 List Set Queue Map 这些对象类型也被叫做集合类。Java类库使用了Collection来指代该类库的一个特殊子集，Java编程思想称之为容器。 容器提供了完善的方法来保存对象 不同的容器有不同的特性：Set对于每一个值只保存一个对象，Map是允许你将某一些对象与其他一些对象关联起来的关联数组。 Java容器类可以自动调整自己的尺寸。 范型与类型安全的容器使用ArrayList的基本步骤： 创建一个实例 用add()插入对象 用get()访问对象 访问对象时需要使用索引，就像数组一样，但是不需要方括号 ArrayList还有一个size()方法，查看List中有多少个元素 注解以@符号开头，可以接受参数 @SuppressWarnings(&quot;unchecked&quot;)表示只有有关”不受检查的异常“的警告信息应该被抑制 如果一个类没有显式的声明继承自哪一个类，那么它将自动继承自Object 定义保存特定类型的ArrayList可以声明 ArrayList&lt;Type&gt;，其中尖括号括起来的就是类型参数，它指定了这个容器类可以保存的类型 通过使用范型，就可以在编译期防止将错误类型对象放置到容器中 将元素从指定了范型的容器中取出，不再需要downcasting向下转型，因为容器知道它保存的是什么类型 java对象的默认打印是由Object默认的toString()方法产生的，该方法将打印类名，后面跟随该对象的散列码的无符号十六进制表示（该散列码是通过hashCode()方法产生的） 基本概念java容器类类库的作用是保存对象，划分为两个概念： Collection，一个独立元素的序列 Map，一组成对的键值对对象 映射表允许我们使用另一个对象来查找某个对象，它也被称为关联数组 创建容器的实例应该创建一个具体类的对象，将其转型为对应的接口，在其余代码内都使用这个接口 添加一组元素Arrays.asList()接收一个数组或一个用逗号分隔的元素列表（使用可变参数），并将其转换为List对象 Collections.addAll()方法接收一个Collection对象，以及一个数组或逗号分割的列表，将元素添加到Collection中 可以在Arrays.asList()中插入一条线索，以告诉编译器对于由该方法产生的List类型，实际的目标类型应该是什么，这是显式类型参数说明 1List&lt;Snow&gt; snow4=Arrays.&lt;Snow&gt;asList(new Light(),new Heavy()); ListList接口在Collection的基础上添加了大量的方法，使得可以在List的中间插入和移除元素 List有两种类型： ArrayList擅长于随即访问元素，但是在LIst中间插入和移除元素时较慢 LinkedList可以已代价较低的在List中间进行插入和删除操作，提供了优化的顺序访问，但是在随机访问方面比较慢，但是他的特性集比ArrayList更大 page 223 迭代器java的Iterator只能单向移动，只能用来： 对Collection容器类使用方法iterator()返回一个Iterator，Iterator将准备号返回序列中的第一个元素 使用next()获得序列中的下一个元素 使用hasNext()检查序列中是否还有元素 使用remove()将迭代器新近返回的元素删除 Iterator也支持范型 Iterator能将遍历序列的操作与序列底层的结构分离 迭代器统一了对容器的访问方式 ListIterator通过调用listIterator()方法产生一个指向List开始处的ListIterator; listIterator(n)可以创建一个一开始就指向列表索引为n的元素处的ListIterator LinkedList 方法名 效果 类似方法 效果差别 getFirst()和element() 返回List的第一个元素，而并不移除它,如果List为空，则抛出NoSuchElementException peek() 如果List为空，则返回null removeFirst()和remove() 移除并返回列表的头，在列表为空时抛出NoSuchElementException poll() 在列表为空时返回null Stack栈通常是指后进先出的容器，最后一个压入栈的元素，第一个弹出栈 12345678public class Stack&lt;T&gt;{ private LinkedList&lt;T&gt; storage=new LinkedList&lt;T&gt;(); public void push(T v){storage.addFirst(v);} public T peek(){return storage.getFirst();} public T pop(){return storage.removeFirst();} public boolean isEmpty{return storage.isEmpty();} public String toString(){return storage.toString();}} 类名之后的告诉编译器这将是一个参数化类型，而其中的类型参数，即在类被使用的时候会被实际类型替换的参数，就是T。大体上就是在声明我们在定义一个可以持有T类型对象的Stack SetSet是基于对象的值来确定归属性的 出于速度原因的考虑，HashSet使用了散列 contains()可以测试Set的归属性 MapJava的自动包装机制会将随机生成的int转化为HashMap可以使用的Integer引用 如果key不在Map容器中，get()方法将返回null，否则get()方法将返回与该键相关联的值对象 Map与数组和其他Collection一样很容易扩展到多维，只需要将其值设置为Map keySet()方法产生Map中所有键组合成的Set Queue队列是典型的先进先出的容器(FIFO) offer()方法将一个元素插入队尾，或者返回false peek()和element()都在不移除元素的情况下返回队头 PriorityQueueFIFO先进先出声明的是下一个元素应该是等待时间最长的元素 优先级队列声明的是下一个弹出的元素应该是最需要的元(具有最高的优先级) 优先级队列在Java SE5中被添加 当我们对一个PriorityQueue调用offer()方法来插入一个对象时，这个对象会在队列中被排序，默认顺序是使用对象在队列中的自然顺序，通过提供自己的Comparator来修改这个顺序 优先级队列可以确保调用peek(),poll(),remove()是，获取的元素是队列中优先级最高的元素 Collection和IteratorCollection是描述所有序列容器的共性的根接口 通过针对接口而非具体类型来编写代码，我们的代码就可以应用于更多的对象类型 Collection和Iterator都可以将显示容器内容的实现与底层容器的特定实现解耦 foreach与迭代器foreach语法可以用于数组和任何Collection对象，实现了Iterable接口的类 适配其方法惯用法覆盖Collection对象，添加一个能够产生Iterable对象的方法","link":"/2019/04/16/《Java编程思想》读书笔记(第十一章)的副本/"},{"title":"《Java编程思想》读书笔记(第十七章)","text":"Collections.nCopies(传入的对象个数，new Object())方法产生List传递给构造器 Collections.fill(需要填充的list对象，new Object())方法替换已经在list中存在的元素，而不能添加新的元素 一种Generator解决方案所有的Collection子类型都有一个能够接受另一个Collection对象的构造器","link":"/2019/05/07/《Java编程思想》读书笔记(第十七章)/"},{"title":"《Java编程思想》读书笔记(第十七章)","text":"Collections.nCopies(传入的对象个数，new Object())方法产生List传递给构造器 Collections.fill(需要填充的list对象，new Object())方法替换已经在list中存在的元素，而不能添加新的元素 一种Generator解决方案所有的Collection子类型都有一个能够接受另一个Collection对象的构造器","link":"/2019/05/07/《Java编程思想》读书笔记(第十七章)的副本/"},{"title":"《Java编程思想》读书笔记(第十三章)","text":"字符串操作是计算机程序设计中最常见的行为 不可变String每当把String对象作为方法的参数时，都会复制一份引用 重载”+”与StringBuilderString对象具有只读特性，因此指向它的任何引用都不可能改变它的值 重载的意思是:一个操作符应用于特定的类时，被赋予了特殊的意义 反编译java代码 1javap -c Concatenation 无意识的递归如果想打印对象的内存地址，应该调用super.toString()方法 String上的操作 方法 构造器 length() charAt() getChars(),getBytes() toCharArray() equals(),equalsIgnoreCase() compareTo() contains() contentEquals() regionMather() startsWith() endWith() indexOf(),lastIndexOf() substring() concat() replace toLowCase(),toUpCase() trim() valueOf() intern() 格式化输出printf()%d,%f叫做格式修饰符，说明了插入数据的位置和数据类型 System.out.format()format方法可以用于PrintSteam或PrintWriter对象 可以用format也可以用printf 123456789101112pulblic class SimpleFormat{ public static void main(String[] args){ int x=5; double y= 2.333333; //the old way System.out.print(\"x = \"+x+\",y = \"+y); //the new format way System.out.format(\"x = %d,y = %f\"，x,y); //or System.out.printf(\"x = %d,y= %f\",x,y); }} Formatter类java中所有新的格式化功能都有java.util.Formatter类处理，可以将Formatter看作一个翻译器 当创建一个Formatter对象时，需要像其构造器传递一些信息 格式化说明符1%[argument_index$][flags][width][.precision]conversion Formatter转换 d 整数型(十进制) c unicode字符 b 布尔值 s String f 浮点数(十进制) e 浮点数(科学计数) x 整数(十六进制) h 散列码(十六进制) % 字符”%” String.format()String.format()是一个静态方法，接收和Formatter.format()一样的参数，但返回一个String对象 正则表达式正则表达式是一种强大而灵活的文本处理工具 match() split() 量词 贪婪型 勉强型 占有型","link":"/2019/04/25/《Java编程思想》读书笔记(第十三章)/"},{"title":"《Java编程思想》读书笔记(第十三章)","text":"字符串操作是计算机程序设计中最常见的行为 不可变String每当把String对象作为方法的参数时，都会复制一份引用 重载”+”与StringBuilderString对象具有只读特性，因此指向它的任何引用都不可能改变它的值 重载的意思是:一个操作符应用于特定的类时，被赋予了特殊的意义 反编译java代码 1javap -c Concatenation 无意识的递归如果想打印对象的内存地址，应该调用super.toString()方法 String上的操作 方法 构造器 length() charAt() getChars(),getBytes() toCharArray() equals(),equalsIgnoreCase() compareTo() contains() contentEquals() regionMather() startsWith() endWith() indexOf(),lastIndexOf() substring() concat() replace toLowCase(),toUpCase() trim() valueOf() intern() 格式化输出printf()%d,%f叫做格式修饰符，说明了插入数据的位置和数据类型 System.out.format()format方法可以用于PrintSteam或PrintWriter对象 可以用format也可以用printf 123456789101112pulblic class SimpleFormat{ public static void main(String[] args){ int x=5; double y= 2.333333; //the old way System.out.print(\"x = \"+x+\",y = \"+y); //the new format way System.out.format(\"x = %d,y = %f\"，x,y); //or System.out.printf(\"x = %d,y= %f\",x,y); }} Formatter类java中所有新的格式化功能都有java.util.Formatter类处理，可以将Formatter看作一个翻译器 当创建一个Formatter对象时，需要像其构造器传递一些信息 格式化说明符1%[argument_index$][flags][width][.precision]conversion Formatter转换 d 整数型(十进制) c unicode字符 b 布尔值 s String f 浮点数(十进制) e 浮点数(科学计数) x 整数(十六进制) h 散列码(十六进制) % 字符”%” String.format()String.format()是一个静态方法，接收和Formatter.format()一样的参数，但返回一个String对象 正则表达式正则表达式是一种强大而灵活的文本处理工具 match() split() 量词 贪婪型 勉强型 占有型","link":"/2019/04/25/《Java编程思想》读书笔记(第十三章)的副本/"},{"title":"《Java编程思想》读书笔记(第十二章)","text":"Java的基本理念是结构不佳的代码不能运行 概念Java的异常处理机制建立在C++的基础之上 异常处理方式将“描述在正常执行过程中做什么事”的代码和“出了问题怎么办”的代码相分离 基本异常exception conidtion异常情形是指阻止当前方法或作用域继续执行的问题 普通问题 异常情形 在当前环境下能得到足够的信息，总能处理这个错误 在当前环境下无法获得必要的信息来解决问题 抛出异常后发生的事情： 使用new在堆上创建异常对象 当前执行路径被终止，并且从当前环境中弹出对异常对象的引用 异常处理机制接管程序，开始寻找恰当的地方来继续执行程序 异常使得我们可以将每件事都当作是一个事物来考虑 异常参数在使用new创建了异常对象之后，此对象的引用将传给throw 异常返回的地点和普通方法调用返回的地点完全不同 能够抛出任意类型的Throwable对象，它是异常类型的根类 通常异常对象中仅有的信息就是异常类型 捕获异常guarded region监视区域是指已端可能会产生异常的代码，并且在后面跟着处理这些异常的代码 try块如果在方法内部抛出了异常，这个方法将在抛出异常的过程中结束。要是不希望方法就此结束，可以在方法内设置一个特殊的块来捕获异常。 123try{ //Code that might generate exception} 异常处理程序异常处理程序将处理在try块中捕获到的异常，以关键字catch表示 12345try{ //Code that might generate exception}catch(Type1 id1){ //Handle exception of Type1} 创建自定义异常要自己定义异常类，必须从已有的异常类继承 1class SimpleException extends Exception{} 在异常处理程序中，调用了在Throwable类声明（Exception即从此类继承）的printStackTrace()方法，它将打印从方法调用处直到异常抛出处的方法调用序列 printStackTrace()方法默认将打印信息输出到标准错误流，如果参数为System.out，则输出到正常log控制台 异常与记录日志java标准类库中的java.util.logging工具将输出记录到日志中 静态的Logger.getLogger()方法创建了一个String参数相关联的Logger对象（通常与错误相关联的包名和类名） 对于异常类来说，getMessage()方法有点类似于toString()方法 异常说明java提供异常说明来告知客户端程序员某个方法可能会抛出的异常类型，它属于方法声明的一部分，紧跟在形式参数列表之后 异常说明使用了附加的关键字throws,后面接一个所有潜在异常类型的列表 1void func() throws TooBig,TooSmall,DivZero{ //...} 如果方法声明未包含异常声明，则表示该方法不会抛出任何异常（除了从RuntimeException继承的异常，它们可以在没有异常说明的情况下被抛出） 捕获所有的异常通过捕获异常类型的基类Exception可以捕获所有类型的异常 Exception可以调用它从其基类Throwable继承的方法： String getMessage() String getLocalizedMessage() String toString() void printStackTrace() Throwable fillInStackTrace() 栈轨迹printStackTrace()方法所提供的信息可以通过getStackTrace()方法来直接访问，getStackTrace()方法返回一个由栈轨迹中的元素所构成的数组 1234567try{ throw new Exception(\"My Exception\");}catch(Exception e){ for(StackTraceElement ste:e.getStackTrace()){ syso(ste.getMethodName()); }} 重新抛出异常在捕获到某个异常后可以将它重新抛出,重抛异常将会把异常交给上一级环境中的异常处理程序，同一个try块的后续catch字句将被忽略 1234catch(Exception e){ syso(\"An exception was thrown\"); throw e;} Java标准异常Throwable这个Java类被用来表示任何可以作为异常被抛出的类 Throwable对象的两种类型： Error用来表示编译时和系统错误 Exception表示可以被抛出的基本类型 如果对null引用进行调用，java会自动抛出NullPointException异常 对于RunTimeException异常类型，Java不需要异常说明，其输出被报告给了System.err 使用finally进行清理无论异常是否被抛出，finally字句总能被执行 在return中使用finally因为finally子句总会执行，所以在一个方法中，可以从多个点返回，并且可以保证重要的清理工作仍旧会执行 page 269","link":"/2019/04/18/《Java编程思想》读书笔记(第十二章)/"},{"title":"《Java编程思想》读书笔记(第十二章)","text":"Java的基本理念是结构不佳的代码不能运行 概念Java的异常处理机制建立在C++的基础之上 异常处理方式将“描述在正常执行过程中做什么事”的代码和“出了问题怎么办”的代码相分离 基本异常exception conidtion异常情形是指阻止当前方法或作用域继续执行的问题 普通问题 异常情形 在当前环境下能得到足够的信息，总能处理这个错误 在当前环境下无法获得必要的信息来解决问题 抛出异常后发生的事情： 使用new在堆上创建异常对象 当前执行路径被终止，并且从当前环境中弹出对异常对象的引用 异常处理机制接管程序，开始寻找恰当的地方来继续执行程序 异常使得我们可以将每件事都当作是一个事物来考虑 异常参数在使用new创建了异常对象之后，此对象的引用将传给throw 异常返回的地点和普通方法调用返回的地点完全不同 能够抛出任意类型的Throwable对象，它是异常类型的根类 通常异常对象中仅有的信息就是异常类型 捕获异常guarded region监视区域是指已端可能会产生异常的代码，并且在后面跟着处理这些异常的代码 try块如果在方法内部抛出了异常，这个方法将在抛出异常的过程中结束。要是不希望方法就此结束，可以在方法内设置一个特殊的块来捕获异常。 123try{ //Code that might generate exception} 异常处理程序异常处理程序将处理在try块中捕获到的异常，以关键字catch表示 12345try{ //Code that might generate exception}catch(Type1 id1){ //Handle exception of Type1} 创建自定义异常要自己定义异常类，必须从已有的异常类继承 1class SimpleException extends Exception{} 在异常处理程序中，调用了在Throwable类声明（Exception即从此类继承）的printStackTrace()方法，它将打印从方法调用处直到异常抛出处的方法调用序列 printStackTrace()方法默认将打印信息输出到标准错误流，如果参数为System.out，则输出到正常log控制台 异常与记录日志java标准类库中的java.util.logging工具将输出记录到日志中 静态的Logger.getLogger()方法创建了一个String参数相关联的Logger对象（通常与错误相关联的包名和类名） 对于异常类来说，getMessage()方法有点类似于toString()方法 异常说明java提供异常说明来告知客户端程序员某个方法可能会抛出的异常类型，它属于方法声明的一部分，紧跟在形式参数列表之后 异常说明使用了附加的关键字throws,后面接一个所有潜在异常类型的列表 1void func() throws TooBig,TooSmall,DivZero{ //...} 如果方法声明未包含异常声明，则表示该方法不会抛出任何异常（除了从RuntimeException继承的异常，它们可以在没有异常说明的情况下被抛出） 捕获所有的异常通过捕获异常类型的基类Exception可以捕获所有类型的异常 Exception可以调用它从其基类Throwable继承的方法： String getMessage() String getLocalizedMessage() String toString() void printStackTrace() Throwable fillInStackTrace() 栈轨迹printStackTrace()方法所提供的信息可以通过getStackTrace()方法来直接访问，getStackTrace()方法返回一个由栈轨迹中的元素所构成的数组 1234567try{ throw new Exception(\"My Exception\");}catch(Exception e){ for(StackTraceElement ste:e.getStackTrace()){ syso(ste.getMethodName()); }} 重新抛出异常在捕获到某个异常后可以将它重新抛出,重抛异常将会把异常交给上一级环境中的异常处理程序，同一个try块的后续catch字句将被忽略 1234catch(Exception e){ syso(\"An exception was thrown\"); throw e;} Java标准异常Throwable这个Java类被用来表示任何可以作为异常被抛出的类 Throwable对象的两种类型： Error用来表示编译时和系统错误 Exception表示可以被抛出的基本类型 如果对null引用进行调用，java会自动抛出NullPointException异常 对于RunTimeException异常类型，Java不需要异常说明，其输出被报告给了System.err 使用finally进行清理无论异常是否被抛出，finally字句总能被执行 在return中使用finally因为finally子句总会执行，所以在一个方法中，可以从多个点返回，并且可以保证重要的清理工作仍旧会执行 page 269","link":"/2019/04/18/《Java编程思想》读书笔记(第十二章)的副本/"},{"title":"《Java编程思想》读书笔记(第十六章)","text":"我突然意识到static和final的含义：static表示它所定义的域和方法对于这个类来说有且仅有一份;final表示它所定义的域对实例来说是不可改变的，final类型的域随实例的创建而被创建，不像static与整个类相关联。同时用static和final修饰域则表示常量，即其对于整个类来说只有一份且不可修改。 12345class BerylliumSphere{ private static long counter; private final long id=counter++; public String toString(){return \"Sphere \"+id;}} 数组为什么特殊数组是一种效率最高的存储和随机访问对象引用序列的方式 在范型出现之前，其他容器类在处理对象时，都将它们视为没有任何具体的类型 数组是第一级对象数组的只读成员length是唯一一个可以访问的字段或方法，表示该数组对象可以存储多少元素，”[]”语法是访问数组对象的唯一方式 length是数组的大小，而不是实际保存的元素的个数 基本类型数组的工作方式和对象数组一样，不过基本类型数组直接存储基本类型数据的值 返回一个数组该节主要展示了一个例子如何随机抽取元素不重复，用了do while循环 多维数组对于基本类型的多维数组，可以使用花括号将每个向量分隔开 1234567public class MutidimensionalPrimitiveArray{ public static void main(String[] args){ int[] a={{1,2,3},{4,5,6}}; System.out.println(Arrays.deepToString(a)); }} Java SE5的Arrays.deepToString()方法可以将多维数组转化为多个String 可以使用new来分配多维数组 1int[][][] a=new int[2][2][4]; 基本类型数组的值在不进行显式初始化的情况下会被自动初始化。对象数组会被初始化为null 数组中构成矩阵的每个向量都可以具有的长度，这被称为粗糙数组 12345678910111213public class RuggedArray{ public static void main(String[] args){ Random rand=new Random(47); int[][][] a=new int[rand.nextInt(7)][][]; for(int i=0;i&lt;a.length;i++){ a[i]=new int[rand.nextInt(5)][]; for(int j=0;j&lt;a[i].length;j++){ a[i][j]=new int[rand.nextInt(5)]; } } System.out.println(Arrays.deepToString(a)); }} 数组与范型不能实例化具有参数化类型的数组，但是可以参数化数组本身的类型 创建测试数据介绍一些用数值或对象来填充数组的工具 Arrays.fill()Arrays.fill(要填充的数组引用,填充的值); Arrays实用功能复制数组可以用System.arrayscopy(),它的参数为源数组引用，源数组开始位置偏移量，目标数组，目标数组开始位置偏移量，需要复制的元素个数 比较数组可以用Arrays.equals()","link":"/2019/05/07/《Java编程思想》读书笔记(第十六章)/"},{"title":"《Java编程思想》读书笔记(第十六章)","text":"我突然意识到static和final的含义：static表示它所定义的域和方法对于这个类来说有且仅有一份;final表示它所定义的域对实例来说是不可改变的，final类型的域随实例的创建而被创建，不像static与整个类相关联。同时用static和final修饰域则表示常量，即其对于整个类来说只有一份且不可修改。 12345class BerylliumSphere{ private static long counter; private final long id=counter++; public String toString(){return \"Sphere \"+id;}} 数组为什么特殊数组是一种效率最高的存储和随机访问对象引用序列的方式 在范型出现之前，其他容器类在处理对象时，都将它们视为没有任何具体的类型 数组是第一级对象数组的只读成员length是唯一一个可以访问的字段或方法，表示该数组对象可以存储多少元素，”[]”语法是访问数组对象的唯一方式 length是数组的大小，而不是实际保存的元素的个数 基本类型数组的工作方式和对象数组一样，不过基本类型数组直接存储基本类型数据的值 返回一个数组该节主要展示了一个例子如何随机抽取元素不重复，用了do while循环 多维数组对于基本类型的多维数组，可以使用花括号将每个向量分隔开 1234567public class MutidimensionalPrimitiveArray{ public static void main(String[] args){ int[] a={{1,2,3},{4,5,6}}; System.out.println(Arrays.deepToString(a)); }} Java SE5的Arrays.deepToString()方法可以将多维数组转化为多个String 可以使用new来分配多维数组 1int[][][] a=new int[2][2][4]; 基本类型数组的值在不进行显式初始化的情况下会被自动初始化。对象数组会被初始化为null 数组中构成矩阵的每个向量都可以具有的长度，这被称为粗糙数组 12345678910111213public class RuggedArray{ public static void main(String[] args){ Random rand=new Random(47); int[][][] a=new int[rand.nextInt(7)][][]; for(int i=0;i&lt;a.length;i++){ a[i]=new int[rand.nextInt(5)][]; for(int j=0;j&lt;a[i].length;j++){ a[i][j]=new int[rand.nextInt(5)]; } } System.out.println(Arrays.deepToString(a)); }} 数组与范型不能实例化具有参数化类型的数组，但是可以参数化数组本身的类型 创建测试数据介绍一些用数值或对象来填充数组的工具 Arrays.fill()Arrays.fill(要填充的数组引用,填充的值); Arrays实用功能复制数组可以用System.arrayscopy(),它的参数为源数组引用，源数组开始位置偏移量，目标数组，目标数组开始位置偏移量，需要复制的元素个数 比较数组可以用Arrays.equals()","link":"/2019/05/07/《Java编程思想》读书笔记(第十六章)的副本/"},{"title":"《Java编程思想》读书笔记(第十四章)","text":"运行时类型信息使得你可以在程序运行时发现和使用类型信息 为什么需要RTTI面向对象编程的基本的目的是：让代码只操纵对基类的引用 通常会创建一个具体对象，把它向上转型为基类 CLASS对象类是程序的一部分，每一个类都有一个class对象 每当编写并且编译了一个新类，就会产生一个class对象（被保存在了一个同名的.class文件中）。为了生成这个类的对象，运行这个类的JVM将使用被称为“类加载器”的子系统 类字面常量java提供类字面常量来生成对Class对象的引用 1FancyToy.class 类字面常量不仅可以应用普通类，也可以应用于接口，数组以及基本数据类型 对于基本数据类型的包装类，还有一个标准字段TYPE 泛化的Class引用为了在使用泛化的Class引用时放松限制，须使用通配符 新的转型语法Java SE5添加了用于Class引用的转型方法，即cast()方法 12House h = houseType.cast(b);h = (House)b; 类型转换前先做检查我们已知的RTTI形式包括： 传统的类型转换 代表对象的类型的Class对象 RTTI在java中的第三种形式是关键字instanceof,它返回一个布尔值，告诉我们对象是不是某个特定类型的实例 123if(x instanceof Dog){ ((Dog)x).bark();} 在进行向下转型前，如果没有其他信息可以告诉你这个对象是什么类型，那么使用instanceof是非常重要的，否则会得到一个ClassCastException异常 反射提供在跨网络的远程平台上创建和运行对象的能力，被成为远程方法调用 Class类和java.lang.reflect类库一起对反射的概念进行了支持 动态代理通过调用静态方法Proxy.newProxyInstance()可以创建动态代理","link":"/2019/04/29/《Java编程思想》读书笔记(第十四章)/"},{"title":"《Java编程思想》读书笔记(第十四章)","text":"运行时类型信息使得你可以在程序运行时发现和使用类型信息 为什么需要RTTI面向对象编程的基本的目的是：让代码只操纵对基类的引用 通常会创建一个具体对象，把它向上转型为基类 CLASS对象类是程序的一部分，每一个类都有一个class对象 每当编写并且编译了一个新类，就会产生一个class对象（被保存在了一个同名的.class文件中）。为了生成这个类的对象，运行这个类的JVM将使用被称为“类加载器”的子系统 类字面常量java提供类字面常量来生成对Class对象的引用 1FancyToy.class 类字面常量不仅可以应用普通类，也可以应用于接口，数组以及基本数据类型 对于基本数据类型的包装类，还有一个标准字段TYPE 泛化的Class引用为了在使用泛化的Class引用时放松限制，须使用通配符 新的转型语法Java SE5添加了用于Class引用的转型方法，即cast()方法 12House h = houseType.cast(b);h = (House)b; 类型转换前先做检查我们已知的RTTI形式包括： 传统的类型转换 代表对象的类型的Class对象 RTTI在java中的第三种形式是关键字instanceof,它返回一个布尔值，告诉我们对象是不是某个特定类型的实例 123if(x instanceof Dog){ ((Dog)x).bark();} 在进行向下转型前，如果没有其他信息可以告诉你这个对象是什么类型，那么使用instanceof是非常重要的，否则会得到一个ClassCastException异常 反射提供在跨网络的远程平台上创建和运行对象的能力，被成为远程方法调用 Class类和java.lang.reflect类库一起对反射的概念进行了支持 动态代理通过调用静态方法Proxy.newProxyInstance()可以创建动态代理","link":"/2019/04/29/《Java编程思想》读书笔记(第十四章)的副本/"},{"title":"《Java编程思想》读书笔记(第十章)","text":"可以将一个类的定义方在另一个类的定义内部，这就是内部类 内部类和组合是完全不同的概念 如果想从外部类的非静态方法之外的任意位置创建某个内部类的对象，那么必须具体的指明这个对象的类型：OuterClassName.InnerClassName 内部类可以实现迭代器设计模式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546interface Selector{ boolean end(); Object current(); void next();}public class Sequence{ private Object[] items; private int next=0; public Sequence(int size){ items=new Object[size]; } public void add(Object x){ if(next &lt; items.length){ items[next ++]=x; } } private class SequenceSelector implements Selector{ private int i = 0; public boolean end(){ return i==items.length; } public Object current(){ return items[i]; } public void next(){ if(i&lt;items.length) i++; } } public Selector selector(){ return new SequenceSelector(); } private static void main(String[] args){ Sequence sequence = new Sequence(10); for(int i=0;i&lt;10;i++){ sequence.add(Integer.toSting(i)); } Selector selector= sequence.selector(); while(!selector.end()){ System.out.print(selector.current()+\" \"); selector.next(); } }} 但某个外部类的对象创建了一个内部类对象时，此内部类对象一定会秘密地捕获一个指向那个外部类对象的引用，在内部类中访问外部类的成员，就是用那个引用来选择外围类的成员 如果你需要生成对外部类对象的引用，可以使用外部类对象的名字后面紧跟dot和this。 1OuterClassName.this .new语法新建内部类 1OuterClassName.InnerClassName oi=o.new InnerClassName(); 在拥有外部类对象之前是不可能创建内部类对象的。内部类对象会暗自连接到创建它的外部类对象上。但是如果创建的是嵌套类（静态内部类），那么它就不需要对外部类对象的引用 anonymous inner class在匿名类定义字段时，还能够对其执行初始化操作 如果定义一个匿名内部类，并且希望它使用一个在其外部定义的对象，那么编译器要求其参数引用是final的 如果不想内部类与其外围类对象之间有联系，可以将内部类声明为static 一个内部类被嵌套多少层都能够透明的访问所有它所嵌套的外围类的所有成员 每个内部类都能独立的继承自一个接口的实现,所以无论外围类是否已经继承了某个接口的实现，对于内部类都没有影响 闭包与回调closure闭包是一个可调用的对象，它记录了一些信息，这些信息来自于创建它的作用域 继承内部类必须初始化指向内部类的外部类引用 12345class InheritanceInnerClass extends OutClass.InnerClass{ InheritanceInnerClass(OutClass outclass){ outclass.super(); }}","link":"/2019/04/16/《Java编程思想》读书笔记(第十章)/"},{"title":"《Java编程思想》读书笔记(第十章)","text":"可以将一个类的定义方在另一个类的定义内部，这就是内部类 内部类和组合是完全不同的概念 如果想从外部类的非静态方法之外的任意位置创建某个内部类的对象，那么必须具体的指明这个对象的类型：OuterClassName.InnerClassName 内部类可以实现迭代器设计模式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546interface Selector{ boolean end(); Object current(); void next();}public class Sequence{ private Object[] items; private int next=0; public Sequence(int size){ items=new Object[size]; } public void add(Object x){ if(next &lt; items.length){ items[next ++]=x; } } private class SequenceSelector implements Selector{ private int i = 0; public boolean end(){ return i==items.length; } public Object current(){ return items[i]; } public void next(){ if(i&lt;items.length) i++; } } public Selector selector(){ return new SequenceSelector(); } private static void main(String[] args){ Sequence sequence = new Sequence(10); for(int i=0;i&lt;10;i++){ sequence.add(Integer.toSting(i)); } Selector selector= sequence.selector(); while(!selector.end()){ System.out.print(selector.current()+\" \"); selector.next(); } }} 但某个外部类的对象创建了一个内部类对象时，此内部类对象一定会秘密地捕获一个指向那个外部类对象的引用，在内部类中访问外部类的成员，就是用那个引用来选择外围类的成员 如果你需要生成对外部类对象的引用，可以使用外部类对象的名字后面紧跟dot和this。 1OuterClassName.this .new语法新建内部类 1OuterClassName.InnerClassName oi=o.new InnerClassName(); 在拥有外部类对象之前是不可能创建内部类对象的。内部类对象会暗自连接到创建它的外部类对象上。但是如果创建的是嵌套类（静态内部类），那么它就不需要对外部类对象的引用 anonymous inner class在匿名类定义字段时，还能够对其执行初始化操作 如果定义一个匿名内部类，并且希望它使用一个在其外部定义的对象，那么编译器要求其参数引用是final的 如果不想内部类与其外围类对象之间有联系，可以将内部类声明为static 一个内部类被嵌套多少层都能够透明的访问所有它所嵌套的外围类的所有成员 每个内部类都能独立的继承自一个接口的实现,所以无论外围类是否已经继承了某个接口的实现，对于内部类都没有影响 闭包与回调closure闭包是一个可调用的对象，它记录了一些信息，这些信息来自于创建它的作用域 继承内部类必须初始化指向内部类的外部类引用 12345class InheritanceInnerClass extends OutClass.InnerClass{ InheritanceInnerClass(OutClass outclass){ outclass.super(); }}","link":"/2019/04/16/《Java编程思想》读书笔记(第十章)的副本/"},{"title":"《Java编程思想》读书笔记(第四章)","text":"所有方法首字母小写的编码规则并不适用于构建器。这是由于构建器的名字必须与类名完全相同！ 不能根据返回值类型来区分过载的方法。 this 关键字（注意只能在方法内部使用）可为已调用了其方法的那个对象生成相应的句柄。可象对待其他任何对象句柄一样对待这个句柄。但要注意，假若准备从自己某个类的另一个方法内部调用一个类方法，就不必使用this。只需简单地调用那个方法即可。 有可能发出这类调用的一种情况是我们将一个对象句柄传到static 方法内部。随后，通过句柄（此时实际是this），我们可调用非 static 方法，并访问非static 字段。 垃圾收集器只知道释放那些由new 分配的内存，所以不知道如何释放对象的“特殊”内存。为解决这个问题，Java 提供了一个名为finalize()的方法，可为我们的类定义它。 垃圾收集器存在的唯一原因是为了回收程序不再使用的内存。 “固有方法”是从Java 里调用非 Java 方法的一种方式。 在这里有必要总结一下对象的创建过程。请考虑一个名为 Dog 的类：(1) 类型为 Dog 的一个对象首次创建时，或者 Dog 类的static 方法／static 字段首次访问时，Java 解释器必须找到Dog.class（在事先设好的类路径里搜索）。(2) 找到Dog.class 后（它会创建一个 Class 对象，这将在后面学到），它的所有 static 初始化模块都会运行。因此，static 初始化仅发生一次——在 Class 对象首次载入的时候。(3) 创建一个new Dog()时，Dog 对象的构建进程首先会在内存堆（Heap）里为一个 Dog 对象分配足够多的存储空间。(4) 这种存储空间会清为零，将Dog 中的所有基本类型设为它们的默认值（零用于数字，以及 boolean 和char 的等价设定）。(5) 进行字段定义时发生的所有初始化都会执行。(6) 执行构建器。正如第6 章将要讲到的那样，这实际可能要求进行相当多的操作，特别是在涉及继承的时候。","link":"/2018/09/07/《Java编程思想》读书笔记(第四章)/"},{"title":"《Java编程思想》读书笔记(第四章)","text":"所有方法首字母小写的编码规则并不适用于构建器。这是由于构建器的名字必须与类名完全相同！ 不能根据返回值类型来区分过载的方法。 this 关键字（注意只能在方法内部使用）可为已调用了其方法的那个对象生成相应的句柄。可象对待其他任何对象句柄一样对待这个句柄。但要注意，假若准备从自己某个类的另一个方法内部调用一个类方法，就不必使用this。只需简单地调用那个方法即可。 有可能发出这类调用的一种情况是我们将一个对象句柄传到static 方法内部。随后，通过句柄（此时实际是this），我们可调用非 static 方法，并访问非static 字段。 垃圾收集器只知道释放那些由new 分配的内存，所以不知道如何释放对象的“特殊”内存。为解决这个问题，Java 提供了一个名为finalize()的方法，可为我们的类定义它。 垃圾收集器存在的唯一原因是为了回收程序不再使用的内存。 “固有方法”是从Java 里调用非 Java 方法的一种方式。 在这里有必要总结一下对象的创建过程。请考虑一个名为 Dog 的类：(1) 类型为 Dog 的一个对象首次创建时，或者 Dog 类的static 方法／static 字段首次访问时，Java 解释器必须找到Dog.class（在事先设好的类路径里搜索）。(2) 找到Dog.class 后（它会创建一个 Class 对象，这将在后面学到），它的所有 static 初始化模块都会运行。因此，static 初始化仅发生一次——在 Class 对象首次载入的时候。(3) 创建一个new Dog()时，Dog 对象的构建进程首先会在内存堆（Heap）里为一个 Dog 对象分配足够多的存储空间。(4) 这种存储空间会清为零，将Dog 中的所有基本类型设为它们的默认值（零用于数字，以及 boolean 和char 的等价设定）。(5) 进行字段定义时发生的所有初始化都会执行。(6) 执行构建器。正如第6 章将要讲到的那样，这实际可能要求进行相当多的操作，特别是在涉及继承的时候。","link":"/2018/09/07/《Java编程思想》读书笔记(第四章)的副本/"},{"title":"廖雪峰Git教程全指令","text":"安装gitsudo apt-get install git 设置姓名和emailgit config --global user.name &quot;your name&quot;git config --global user.email &quot;your email&quot; 创建文件夹mkdir yourdirname 进入文件夹cd yourdirname 显示当前目录pwd 初始化git仓库git init 查看文件夹内全部内容ls -ah 在youdirname文件夹内创建文件gedit readme.txt 把文件添加至仓库git add readme.txt 把文件提交至仓库git commit -as 查看仓库当前状态git status 查看仓库内文件具体改变git diff 查看仓库提交历史记录git log 查看仓库提交历史记录（一行显示一次提交）git log --pretty=oneline 回退提交版本（HEAD仅仅是一个指针,标识当前版本，上一个版本是HEAD^,上上个版本是HEAD^^）git reset --hard HEAD^ 查看每一次git操作记录git reflog 查看工作区和版本库里最新版本的区别git diff HEAD -- yourfilename 将工作区里的修改撤销git checkout -- yourfilename 将暂存区stage中的修改撤销git reset HEAD yourfilename 删除文件rm yourfilename 从版本库中删除文件git rm yourfilename 创建SSH Keyssh-keygen -t rsa -C &quot;youremail@example.com&quot; 添加远程仓库(本地仓库和远程仓库建立连接)git remote add origin git@github.com:yourgithubname/demo.git 向远程仓库推送本地库内容git push -u origin master 克隆一个本地库git clone git@github.com:yourgithubname/demo.git 创建分支并切换到新的分支git checkout -b newbranchname 创建分支git branch newbranchname 切换分支git checkout newbranchname 显示当前所有分支git branch 合并指定分支到当前分支git merge devbranchname 删除分支git branch -d devbranchname 不以fast-forward策略的合并分支git merge --no-f -m &quot;merge information&quot; devbranchname 查看提交历史记录，显示分支图，简短提交记录，提交记录单行显示git log --graph --pretty=oneline --abbrev-commit 藏匿工作区现场git stash 恢复stash内容git stash apply 删除stash内容git stash drop 恢复stash内容同时删除stash内容git stash pop 强行删除分支git branch -D devbranchname 查看远程库信息(-v查看更详细信息)git remote 推送本地分支提交到远程库git push origin master 将最新的与远程库代码抓下来git pull 建立本地分支和远程分支的关联git branch --set-upstream-to=origin/dev dev 常用命令设置别名git config --global alias.co checkout 设置lggit config --global alias.lg &quot;log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit&quot;","link":"/2019/04/04/廖雪峰Git教程全指令/"},{"title":"廖雪峰Git教程全指令","text":"安装gitsudo apt-get install git 设置姓名和emailgit config --global user.name &quot;your name&quot;git config --global user.email &quot;your email&quot; 创建文件夹mkdir yourdirname 进入文件夹cd yourdirname 显示当前目录pwd 初始化git仓库git init 查看文件夹内全部内容ls -ah 在youdirname文件夹内创建文件gedit readme.txt 把文件添加至仓库git add readme.txt 把文件提交至仓库git commit -as 查看仓库当前状态git status 查看仓库内文件具体改变git diff 查看仓库提交历史记录git log 查看仓库提交历史记录（一行显示一次提交）git log --pretty=oneline 回退提交版本（HEAD仅仅是一个指针,标识当前版本，上一个版本是HEAD^,上上个版本是HEAD^^）git reset --hard HEAD^ 查看每一次git操作记录git reflog 查看工作区和版本库里最新版本的区别git diff HEAD -- yourfilename 将工作区里的修改撤销git checkout -- yourfilename 将暂存区stage中的修改撤销git reset HEAD yourfilename 删除文件rm yourfilename 从版本库中删除文件git rm yourfilename 创建SSH Keyssh-keygen -t rsa -C &quot;youremail@example.com&quot; 添加远程仓库(本地仓库和远程仓库建立连接)git remote add origin git@github.com:yourgithubname/demo.git 向远程仓库推送本地库内容git push -u origin master 克隆一个本地库git clone git@github.com:yourgithubname/demo.git 创建分支并切换到新的分支git checkout -b newbranchname 创建分支git branch newbranchname 切换分支git checkout newbranchname 显示当前所有分支git branch 合并指定分支到当前分支git merge devbranchname 删除分支git branch -d devbranchname 不以fast-forward策略的合并分支git merge --no-f -m &quot;merge information&quot; devbranchname 查看提交历史记录，显示分支图，简短提交记录，提交记录单行显示git log --graph --pretty=oneline --abbrev-commit 藏匿工作区现场git stash 恢复stash内容git stash apply 删除stash内容git stash drop 恢复stash内容同时删除stash内容git stash pop 强行删除分支git branch -D devbranchname 查看远程库信息(-v查看更详细信息)git remote 推送本地分支提交到远程库git push origin master 将最新的与远程库代码抓下来git pull 建立本地分支和远程分支的关联git branch --set-upstream-to=origin/dev dev 常用命令设置别名git config --global alias.co checkout 设置lggit config --global alias.lg &quot;log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit&quot;","link":"/2019/04/04/廖雪峰Git教程全指令的副本/"},{"title":"Android MVP框架学习笔记（进阶）","text":"本学习笔记总结自文章Android MVP架构搭建 引言在学习Android MVP的过程中，我发现第一篇文章中的MVP结构存在诸多问题，一是对每一个Activity都需要写一套MVP结构，异常麻烦；二是Model层中只包含JavaBean，未包含数据请求部分，导致presenter层中需要加上数据请求。 学习了这篇文章后我觉得主要掌握的几点有： 为MVP各层级添加base基类和范型大大增加复用性 对view层为null的情况做兼容处理 对model层请求数据采用callback的方式通知presenter层实现view层界面的刷新 而我对MVP更深一步的理解是： presenter层是单纯的Java类，只负责处理逻辑业务 model层包括JavaBean和数据请求 所有的Android API应该在view层的Activity或Fragment中实现 架构组成进阶版的MVP架构有几个方面组成： MVP结构的base基类：BaseActivity，BaseView，BasePresenter,Callback 实现基类的MVP结构类：Model，MvpView，MvpPresenter，MvpActivity 具体实现大概就在这8个类里。 实现步骤 BaseView 123456789101112131415161718192021222324public interface BaseView { /** * 显示正在加载view */ void showLoading(); /** * 关闭正在加载view */ void hideLoading(); /** * 显示提示 * @param msg */ void showToast(String msg); /** * 显示请求错误提示 */ void showErr(); /** * 获取上下文 * @return 上下文 */ Context getContext();} BaseActivity 1234567891011121314151617181920212223242526272829303132public abstract class BaseActivity extends Activity implements IBaseView { private ProgressDialog mProgressDialog; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); mProgressDialog = new ProgressDialog(this); mProgressDialog.setCancelable(false); } @Override public void showLoading() { if (!mProgressDialog.isShowing()) { mProgressDialog.show(); } } @Override public void hideLoading() { if (mProgressDialog.isShowing()) { mProgressDialog.dismiss(); } } @Override public void showToast(String msg) { Toast.makeText(this, msg, Toast.LENGTH_SHORT).show(); } @Override public void showErr() { showToast(getResources().getString(R.string.api_error_msg)); } @Override public Context getContext() { return BaseActivity.this; } Callback 12345678910111213141516171819202122public interface Callback&lt;T&gt; { /** * 数据请求成功 * @param data 请求到的数据 */ void onSuccess(T data); /** * 使用网络API接口请求方式时，虽然已经请求成功但是由 * 于{@code msg}的原因无法正常返回数据。 */ void onFailure(String msg); /** * 请求数据失败，指在请求网络API接口请求方式时，出现无法联网、 * 缺少权限，内存泄露等原因导致无法连接到请求数据源。 */ void onError(); /** * 当请求数据结束时，无论请求结果是成功，失败或是抛出异常都会执行此方法给用户做处理，通常做网络 * 请求时可以在此处隐藏“正在加载”的等待控件 */ void onComplete();} BasePresenter 1234567891011121314151617181920212223242526272829303132public class BasePresenter&lt;V extends IBaseView&gt; { /** * 绑定的view */ private V mvpView; /** * 绑定view，一般在初始化中调用该方法 */ @Override public void attachView(V mvpView) { this.mvpView = mvpView; } /** * 断开view，一般在onDestroy中调用 */ @Override public void detachView() { this.mvpView = null; } /** * 是否与View建立连接 * 每次调用业务请求的时候都要出先调用方法检查是否与View建立连接 */ public boolean isViewAttached(){ return mvpView != null; } /** * 获取连接的view */ public V getView(){ return mvpView; } Model 需要注意model层中数据请求的方法都是静态方法，故参数前面需要final修饰 123456789101112131415161718192021222324252627public class MvpModel { /** * 获取网络接口数据 * @param param 请求参数 * @param callback 数据回调接口 */ public static void getNetData(final String param, final MvpCallback&lt;String&gt; callback){ // 利用postDelayed方法模拟网络请求数据的耗时操作 new Handler().postDelayed(new Runnable() { @Override public void run() { switch (param){ case \"normal\": callback.onSuccess(\"根据参数\"+param+\"的请求网络数据成功\"); break; case \"failure\": callback.onFailure(\"请求失败：参数有误\"); break; case \"error\": callback.onError(); break; } callback.onComplete(); } },2000); }} 实现基类的View层 基类中已经存在的方法就不用写进子类了，增加了复用性 1234567public interface MvpView extends BaseView{ /** * 当数据请求成功后，调用此接口显示数据 * @param data 数据源 */ void showData(String data);} 实现了基类的presenter层 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class MvpPresenter extends BasePresenter&lt;MvpView &gt; { /** * 获取网络数据 * @param params 参数 */ public void getData(String params){ if (!isViewAttached()){ //如果没有View引用就不加载数据 return; } //显示正在加载进度条 getView().showLoading(); // 调用Model请求数据 MvpModel.getNetData(params, new MvpCallback()&lt;String&gt; { @Override public void onSuccess(String data) { //调用view接口显示数据 if(isViewAttached()){ getView().showData(data); } } @Override public void onFailure(String msg) { //调用view接口提示失败信息 if(isViewAttached()){ getView().showToast(msg); } } @Override public void onError() { //调用view接口提示请求异常 if(isViewAttached()){ getView().showErr(); } } @Override public void onComplete() { // 隐藏正在加载进度条 if(isViewAttached()){ getView().hideLoading(); } } }); }} 实现了基类的Activity 1234567891011121314151617181920212223242526272829303132333435public class MainActivity extends BaseActivity implements MvpView { TextView text; MvpPresenter presenter; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); text = (TextView)findViewById(R.id.text); //初始化Presenter presenter = new MvpPresenter(); presenter.attachView(this); } @Override protected void onDestroy() { super.onDestroy(); //断开View引用 presenter.detachView(); } @Override public void showData(String data) { text.setText(data); } // button 点击事件调用方法 public void getData(View view){ presenter.getData(\"normal\"); } // button 点击事件调用方法 public void getDataForFailure(View view){ presenter.getData(\"failure\"); } // button 点击事件调用方法 public void getDataForError(View view){ presenter.getData(\"error\"); } } fragment实现MVP的方法同BaseActivity一样，需要构造一个BaseFragment基类。 需要注意的是： 需要在onCreateView()生命周期方法中通过getActivity()方法拿到上下文参数，在实现BaseView接口的方法时，调用其容器Activity的上下文来实现父容器的界面刷新。 在调用父容器界面方法之前，需要用getActivity()是否null来检查与Activity的连接情况。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public abstract class BaseFragment extends Fragment implements BaseView { public abstract int getContentViewId(); protected abstract void initAllMembersView(Bundle savedInstanceState); protected Context mContext; protected View mRootView; @Nullable @Override public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) { mRootView = inflater.inflate(getContentViewId(), container, false); this.mContext = getActivity(); initAllMembersView(savedInstanceState); return mRootView; } @Override public void showLoading() { checkActivityAttached(); ((BaseFragmentActivity) mContext).showLoading(); } @Override public void showLoading(String msg) { checkActivityAttached(); ((BaseFragmentActivity) mContext).showLoading(msg); } @Override public void hideLoading() { checkActivityAttached(); ((BaseFragmentActivity) mContext).hideLoading(); } @Override public void showToast(String msg) { checkActivityAttached(); ((BaseFragmentActivity) mContext).showToast(msg); } @Override public void showErr() { checkActivityAttached(); ((BaseFragmentActivity) mContext).showErr(); } protected boolean isAttachedContext(){ return getActivity() != null; } /** * 检查activity连接情况 */ public void checkActivityAttached() { if (getActivity() == null) { throw new ActivityNotAttachedException(); } } public static class ActivityNotAttachedException extends RuntimeException { public ActivityNotAttachedException() { super(\"Fragment has disconnected from Activity ! - -.\"); } }}","link":"/2018/12/04/Android MVP框架学习笔记2/"},{"title":"Android MVP框架学习笔记（进阶）","text":"本学习笔记总结自文章Android MVP架构搭建 引言在学习Android MVP的过程中，我发现第一篇文章中的MVP结构存在诸多问题，一是对每一个Activity都需要写一套MVP结构，异常麻烦；二是Model层中只包含JavaBean，未包含数据请求部分，导致presenter层中需要加上数据请求。 学习了这篇文章后我觉得主要掌握的几点有： 为MVP各层级添加base基类和范型大大增加复用性 对view层为null的情况做兼容处理 对model层请求数据采用callback的方式通知presenter层实现view层界面的刷新 而我对MVP更深一步的理解是： presenter层是单纯的Java类，只负责处理逻辑业务 model层包括JavaBean和数据请求 所有的Android API应该在view层的Activity或Fragment中实现 架构组成进阶版的MVP架构有几个方面组成： MVP结构的base基类：BaseActivity，BaseView，BasePresenter,Callback 实现基类的MVP结构类：Model，MvpView，MvpPresenter，MvpActivity 具体实现大概就在这8个类里。 实现步骤 BaseView 123456789101112131415161718192021222324public interface BaseView { /** * 显示正在加载view */ void showLoading(); /** * 关闭正在加载view */ void hideLoading(); /** * 显示提示 * @param msg */ void showToast(String msg); /** * 显示请求错误提示 */ void showErr(); /** * 获取上下文 * @return 上下文 */ Context getContext();} BaseActivity 1234567891011121314151617181920212223242526272829303132public abstract class BaseActivity extends Activity implements IBaseView { private ProgressDialog mProgressDialog; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); mProgressDialog = new ProgressDialog(this); mProgressDialog.setCancelable(false); } @Override public void showLoading() { if (!mProgressDialog.isShowing()) { mProgressDialog.show(); } } @Override public void hideLoading() { if (mProgressDialog.isShowing()) { mProgressDialog.dismiss(); } } @Override public void showToast(String msg) { Toast.makeText(this, msg, Toast.LENGTH_SHORT).show(); } @Override public void showErr() { showToast(getResources().getString(R.string.api_error_msg)); } @Override public Context getContext() { return BaseActivity.this; } Callback 12345678910111213141516171819202122public interface Callback&lt;T&gt; { /** * 数据请求成功 * @param data 请求到的数据 */ void onSuccess(T data); /** * 使用网络API接口请求方式时，虽然已经请求成功但是由 * 于{@code msg}的原因无法正常返回数据。 */ void onFailure(String msg); /** * 请求数据失败，指在请求网络API接口请求方式时，出现无法联网、 * 缺少权限，内存泄露等原因导致无法连接到请求数据源。 */ void onError(); /** * 当请求数据结束时，无论请求结果是成功，失败或是抛出异常都会执行此方法给用户做处理，通常做网络 * 请求时可以在此处隐藏“正在加载”的等待控件 */ void onComplete();} BasePresenter 1234567891011121314151617181920212223242526272829303132public class BasePresenter&lt;V extends IBaseView&gt; { /** * 绑定的view */ private V mvpView; /** * 绑定view，一般在初始化中调用该方法 */ @Override public void attachView(V mvpView) { this.mvpView = mvpView; } /** * 断开view，一般在onDestroy中调用 */ @Override public void detachView() { this.mvpView = null; } /** * 是否与View建立连接 * 每次调用业务请求的时候都要出先调用方法检查是否与View建立连接 */ public boolean isViewAttached(){ return mvpView != null; } /** * 获取连接的view */ public V getView(){ return mvpView; } Model 需要注意model层中数据请求的方法都是静态方法，故参数前面需要final修饰 123456789101112131415161718192021222324252627public class MvpModel { /** * 获取网络接口数据 * @param param 请求参数 * @param callback 数据回调接口 */ public static void getNetData(final String param, final MvpCallback&lt;String&gt; callback){ // 利用postDelayed方法模拟网络请求数据的耗时操作 new Handler().postDelayed(new Runnable() { @Override public void run() { switch (param){ case \"normal\": callback.onSuccess(\"根据参数\"+param+\"的请求网络数据成功\"); break; case \"failure\": callback.onFailure(\"请求失败：参数有误\"); break; case \"error\": callback.onError(); break; } callback.onComplete(); } },2000); }} 实现基类的View层 基类中已经存在的方法就不用写进子类了，增加了复用性 1234567public interface MvpView extends BaseView{ /** * 当数据请求成功后，调用此接口显示数据 * @param data 数据源 */ void showData(String data);} 实现了基类的presenter层 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class MvpPresenter extends BasePresenter&lt;MvpView &gt; { /** * 获取网络数据 * @param params 参数 */ public void getData(String params){ if (!isViewAttached()){ //如果没有View引用就不加载数据 return; } //显示正在加载进度条 getView().showLoading(); // 调用Model请求数据 MvpModel.getNetData(params, new MvpCallback()&lt;String&gt; { @Override public void onSuccess(String data) { //调用view接口显示数据 if(isViewAttached()){ getView().showData(data); } } @Override public void onFailure(String msg) { //调用view接口提示失败信息 if(isViewAttached()){ getView().showToast(msg); } } @Override public void onError() { //调用view接口提示请求异常 if(isViewAttached()){ getView().showErr(); } } @Override public void onComplete() { // 隐藏正在加载进度条 if(isViewAttached()){ getView().hideLoading(); } } }); }} 实现了基类的Activity 1234567891011121314151617181920212223242526272829303132333435public class MainActivity extends BaseActivity implements MvpView { TextView text; MvpPresenter presenter; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); text = (TextView)findViewById(R.id.text); //初始化Presenter presenter = new MvpPresenter(); presenter.attachView(this); } @Override protected void onDestroy() { super.onDestroy(); //断开View引用 presenter.detachView(); } @Override public void showData(String data) { text.setText(data); } // button 点击事件调用方法 public void getData(View view){ presenter.getData(\"normal\"); } // button 点击事件调用方法 public void getDataForFailure(View view){ presenter.getData(\"failure\"); } // button 点击事件调用方法 public void getDataForError(View view){ presenter.getData(\"error\"); } } fragment实现MVP的方法同BaseActivity一样，需要构造一个BaseFragment基类。 需要注意的是： 需要在onCreateView()生命周期方法中通过getActivity()方法拿到上下文参数，在实现BaseView接口的方法时，调用其容器Activity的上下文来实现父容器的界面刷新。 在调用父容器界面方法之前，需要用getActivity()是否null来检查与Activity的连接情况。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public abstract class BaseFragment extends Fragment implements BaseView { public abstract int getContentViewId(); protected abstract void initAllMembersView(Bundle savedInstanceState); protected Context mContext; protected View mRootView; @Nullable @Override public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) { mRootView = inflater.inflate(getContentViewId(), container, false); this.mContext = getActivity(); initAllMembersView(savedInstanceState); return mRootView; } @Override public void showLoading() { checkActivityAttached(); ((BaseFragmentActivity) mContext).showLoading(); } @Override public void showLoading(String msg) { checkActivityAttached(); ((BaseFragmentActivity) mContext).showLoading(msg); } @Override public void hideLoading() { checkActivityAttached(); ((BaseFragmentActivity) mContext).hideLoading(); } @Override public void showToast(String msg) { checkActivityAttached(); ((BaseFragmentActivity) mContext).showToast(msg); } @Override public void showErr() { checkActivityAttached(); ((BaseFragmentActivity) mContext).showErr(); } protected boolean isAttachedContext(){ return getActivity() != null; } /** * 检查activity连接情况 */ public void checkActivityAttached() { if (getActivity() == null) { throw new ActivityNotAttachedException(); } } public static class ActivityNotAttachedException extends RuntimeException { public ActivityNotAttachedException() { super(\"Fragment has disconnected from Activity ! - -.\"); } }}","link":"/2018/12/04/Android MVP框架学习笔记2的副本/"},{"title":"Android原生TTS逻辑分析","text":"本文依据API 28的安卓源码文件UtteranceProgressListener.java分析整理得出 What is UtteranceProgressListenerUtteranceProgressListener实际上是一个抽象类，它是一个监听器，监听与发声的过程相关的事件，这个事件是通过很多步骤来处理的。每一个TTS发声事件都与函数调用相关联，分别是TextToSpeech#speak和TextToSpeech#synthesizeToFile.并且有唯一的发声ID(utterance identifier)来标识自己。这个ID就是TextToSpeech.Engine#KEY_PARAM_UTTERANCE_ID TTS回调类型 onStart(String utteranceId)该回调会在TTS发声之前被调用，TTS发声是由于TextToSpeech#speak或TextToSpeech#synthesizeToFile的调用引起的，参数为该发声事件的发声ID(utteranceId) onDone(String utteranceId)当TTS发声过程成功完成后（要说的话从头到尾一字不落全说完），调用该回调。可以保证onDone回调一定是在对应的onStart回调之后调用的,参数为该发声事件的发声ID(utteranceId) onError(String utteranceId)当TTS发声过程中出现一个错误时调用该回调，在TTS语音合成过程的任意时间点都可以调用该回调，一个onStart只对应一个onDone或onError回调,参数为该发声事件的发声ID(utteranceId) onError(String utteranceId, int errorCode)当TTS发声过程中出现一个错误时调用该回调，在TTS语音合成过程的任意时间点都可以调用该回调，一个onStart只对应一个onDone或onError回调，比单参数错误回调多返回一个来自TextToSpeech的错误代码(ERROR_* codes from TextToSpeech) onStop(String utteranceId, boolean interrupted)当TTS播放过程中停止播放或合成队列刷新过程时调用该回调，这个回调可以发生在调用TextToSpeech#stop()方法或者使用TextToSpeech#QUEUE_FLUSH作为参数调用TextToSpeech#speak和TextToSpeech#synthesizeToFile方法时.参数为该发声事件的发声ID(utteranceId)和布尔型参数interrupted.interrupted为true时，TTS发声过程将在正在语音合成的过程中被打断，且输出是不完整的;为flase时，TTS发声事件将在语音合成开始之前被刷新 - 文件源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182// Copyright 2011 Google Inc. All Rights Reserved.package android.speech.tts;import android.media.AudioFormat;/** * Listener for events relating to the progress of an utterance through * the synthesis queue. Each utterance is associated with a call to * {@link TextToSpeech#speak} or {@link TextToSpeech#synthesizeToFile} with an * associated utterance identifier, as per {@link TextToSpeech.Engine#KEY_PARAM_UTTERANCE_ID}. * * The callbacks specified in this method can be called from multiple threads. */public abstract class UtteranceProgressListener { /** * Called when an utterance \"starts\" as perceived by the caller. This will * be soon before audio is played back in the case of a {@link TextToSpeech#speak} * or before the first bytes of a file are written to the file system in the case * of {@link TextToSpeech#synthesizeToFile}. * * @param utteranceId The utterance ID of the utterance. */ public abstract void onStart(String utteranceId); /** * Called when an utterance has successfully completed processing. * All audio will have been played back by this point for audible output, and all * output will have been written to disk for file synthesis requests. * * This request is guaranteed to be called after {@link #onStart(String)}. * * @param utteranceId The utterance ID of the utterance. */ public abstract void onDone(String utteranceId); /** * Called when an error has occurred during processing. This can be called * at any point in the synthesis process. Note that there might be calls * to {@link #onStart(String)} for specified utteranceId but there will never * be a call to both {@link #onDone(String)} and {@link #onError(String)} for * the same utterance. * * @param utteranceId The utterance ID of the utterance. * @deprecated Use {@link #onError(String,int)} instead */ @Deprecated public abstract void onError(String utteranceId); /** * Called when an error has occurred during processing. This can be called * at any point in the synthesis process. Note that there might be calls * to {@link #onStart(String)} for specified utteranceId but there will never * be a call to both {@link #onDone(String)} and {@link #onError(String,int)} for * the same utterance. The default implementation calls {@link #onError(String)}. * * @param utteranceId The utterance ID of the utterance. * @param errorCode one of the ERROR_* codes from {@link TextToSpeech} */ public void onError(String utteranceId, int errorCode) { onError(utteranceId); } /** * Called when an utterance has been stopped while in progress or flushed from the * synthesis queue. This can happen if a client calls {@link TextToSpeech#stop()} * or uses {@link TextToSpeech#QUEUE_FLUSH} as an argument with the * {@link TextToSpeech#speak} or {@link TextToSpeech#synthesizeToFile} methods. * * @param utteranceId The utterance ID of the utterance. * @param interrupted If true, then the utterance was interrupted while being synthesized * and its output is incomplete. If false, then the utterance was flushed * before the synthesis started. */ public void onStop(String utteranceId, boolean interrupted) { } /** * Called when the TTS engine begins to synthesize the audio for a request. * * &lt;p&gt; * It provides information about the format of the byte array for subsequent * {@link #onAudioAvailable} calls. * &lt;/p&gt; * * &lt;p&gt; * This is called when the TTS engine starts synthesizing audio for the request. If an * application wishes to know when the audio is about to start playing, {#onStart(String)} * should be used instead. * &lt;/p&gt; * * @param utteranceId The utterance ID of the utterance. * @param sampleRateInHz Sample rate in hertz of the generated audio. * @param audioFormat Audio format of the generated audio. Should be one of * {@link AudioFormat#ENCODING_PCM_8BIT}, {@link AudioFormat#ENCODING_PCM_16BIT} or * {@link AudioFormat#ENCODING_PCM_FLOAT}. * @param channelCount The number of channels. */ public void onBeginSynthesis(String utteranceId, int sampleRateInHz, int audioFormat, int channelCount) { } /** * This is called when a chunk of audio is ready for consumption. * * &lt;p&gt; * The audio parameter is a copy of what will be synthesized to the speakers (when synthesis was * initiated with a {@link TextToSpeech#speak} call) or written to the file system (for * {@link TextToSpeech#synthesizeToFile}). The audio bytes are delivered in one or more chunks; * if {@link #onDone} or {@link #onError} is called all chunks have been received. * &lt;/p&gt; * * &lt;p&gt; * The audio received here may not be played for some time depending on buffer sizes and the * amount of items on the synthesis queue. * &lt;/p&gt; * * @param utteranceId The utterance ID of the utterance. * @param audio A chunk of audio; the format can be known by listening to * {@link #onBeginSynthesis(String, int, int, int)}. */ public void onAudioAvailable(String utteranceId, byte[] audio) { } /** * This is called when the TTS service is about to speak the specified range of the utterance * with the given utteranceId. * * &lt;p&gt;This method is called when the audio is expected to start playing on the speaker. Note * that this is different from {@link #onAudioAvailable} which is called as soon as the audio is * generated. * &lt;p&gt;This information can be used, for example, to highlight ranges of the text while it is * spoken. * * &lt;p&gt;Only called if the engine supplies timing information by calling {@link * SynthesisCallback#rangeStart(int, int, int)}. * * @param utteranceId Unique id identifying the synthesis request. * @param start The start index of the range in the utterance text. * @param end The end index of the range (exclusive) in the utterance text. * @param frame The position in frames in the audio of the request where this range is spoken. */ public void onRangeStart(String utteranceId, int start, int end, int frame) { onUtteranceRangeStart(utteranceId, start, end); } /** @removed */ @Deprecated public void onUtteranceRangeStart(String utteranceId, int start, int end) { } /** * Wraps an old deprecated OnUtteranceCompletedListener with a shiny new progress listener. * * @hide */ static UtteranceProgressListener from( final TextToSpeech.OnUtteranceCompletedListener listener) { return new UtteranceProgressListener() { @Override public synchronized void onDone(String utteranceId) { listener.onUtteranceCompleted(utteranceId); } @Override public void onError(String utteranceId) { listener.onUtteranceCompleted(utteranceId); } @Override public void onStart(String utteranceId) { // Left unimplemented, has no equivalent in the old // API. } @Override public void onStop(String utteranceId, boolean interrupted) { listener.onUtteranceCompleted(utteranceId); } }; }}","link":"/2019/04/12/Android原生TTS逻辑分析/"},{"title":"Android原生TTS逻辑分析","text":"本文依据API 28的安卓源码文件UtteranceProgressListener.java分析整理得出 What is UtteranceProgressListenerUtteranceProgressListener实际上是一个抽象类，它是一个监听器，监听与发声的过程相关的事件，这个事件是通过很多步骤来处理的。每一个TTS发声事件都与函数调用相关联，分别是TextToSpeech#speak和TextToSpeech#synthesizeToFile.并且有唯一的发声ID(utterance identifier)来标识自己。这个ID就是TextToSpeech.Engine#KEY_PARAM_UTTERANCE_ID TTS回调类型 onStart(String utteranceId)该回调会在TTS发声之前被调用，TTS发声是由于TextToSpeech#speak或TextToSpeech#synthesizeToFile的调用引起的，参数为该发声事件的发声ID(utteranceId) onDone(String utteranceId)当TTS发声过程成功完成后（要说的话从头到尾一字不落全说完），调用该回调。可以保证onDone回调一定是在对应的onStart回调之后调用的,参数为该发声事件的发声ID(utteranceId) onError(String utteranceId)当TTS发声过程中出现一个错误时调用该回调，在TTS语音合成过程的任意时间点都可以调用该回调，一个onStart只对应一个onDone或onError回调,参数为该发声事件的发声ID(utteranceId) onError(String utteranceId, int errorCode)当TTS发声过程中出现一个错误时调用该回调，在TTS语音合成过程的任意时间点都可以调用该回调，一个onStart只对应一个onDone或onError回调，比单参数错误回调多返回一个来自TextToSpeech的错误代码(ERROR_* codes from TextToSpeech) onStop(String utteranceId, boolean interrupted)当TTS播放过程中停止播放或合成队列刷新过程时调用该回调，这个回调可以发生在调用TextToSpeech#stop()方法或者使用TextToSpeech#QUEUE_FLUSH作为参数调用TextToSpeech#speak和TextToSpeech#synthesizeToFile方法时.参数为该发声事件的发声ID(utteranceId)和布尔型参数interrupted.interrupted为true时，TTS发声过程将在正在语音合成的过程中被打断，且输出是不完整的;为flase时，TTS发声事件将在语音合成开始之前被刷新 - 文件源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182// Copyright 2011 Google Inc. All Rights Reserved.package android.speech.tts;import android.media.AudioFormat;/** * Listener for events relating to the progress of an utterance through * the synthesis queue. Each utterance is associated with a call to * {@link TextToSpeech#speak} or {@link TextToSpeech#synthesizeToFile} with an * associated utterance identifier, as per {@link TextToSpeech.Engine#KEY_PARAM_UTTERANCE_ID}. * * The callbacks specified in this method can be called from multiple threads. */public abstract class UtteranceProgressListener { /** * Called when an utterance \"starts\" as perceived by the caller. This will * be soon before audio is played back in the case of a {@link TextToSpeech#speak} * or before the first bytes of a file are written to the file system in the case * of {@link TextToSpeech#synthesizeToFile}. * * @param utteranceId The utterance ID of the utterance. */ public abstract void onStart(String utteranceId); /** * Called when an utterance has successfully completed processing. * All audio will have been played back by this point for audible output, and all * output will have been written to disk for file synthesis requests. * * This request is guaranteed to be called after {@link #onStart(String)}. * * @param utteranceId The utterance ID of the utterance. */ public abstract void onDone(String utteranceId); /** * Called when an error has occurred during processing. This can be called * at any point in the synthesis process. Note that there might be calls * to {@link #onStart(String)} for specified utteranceId but there will never * be a call to both {@link #onDone(String)} and {@link #onError(String)} for * the same utterance. * * @param utteranceId The utterance ID of the utterance. * @deprecated Use {@link #onError(String,int)} instead */ @Deprecated public abstract void onError(String utteranceId); /** * Called when an error has occurred during processing. This can be called * at any point in the synthesis process. Note that there might be calls * to {@link #onStart(String)} for specified utteranceId but there will never * be a call to both {@link #onDone(String)} and {@link #onError(String,int)} for * the same utterance. The default implementation calls {@link #onError(String)}. * * @param utteranceId The utterance ID of the utterance. * @param errorCode one of the ERROR_* codes from {@link TextToSpeech} */ public void onError(String utteranceId, int errorCode) { onError(utteranceId); } /** * Called when an utterance has been stopped while in progress or flushed from the * synthesis queue. This can happen if a client calls {@link TextToSpeech#stop()} * or uses {@link TextToSpeech#QUEUE_FLUSH} as an argument with the * {@link TextToSpeech#speak} or {@link TextToSpeech#synthesizeToFile} methods. * * @param utteranceId The utterance ID of the utterance. * @param interrupted If true, then the utterance was interrupted while being synthesized * and its output is incomplete. If false, then the utterance was flushed * before the synthesis started. */ public void onStop(String utteranceId, boolean interrupted) { } /** * Called when the TTS engine begins to synthesize the audio for a request. * * &lt;p&gt; * It provides information about the format of the byte array for subsequent * {@link #onAudioAvailable} calls. * &lt;/p&gt; * * &lt;p&gt; * This is called when the TTS engine starts synthesizing audio for the request. If an * application wishes to know when the audio is about to start playing, {#onStart(String)} * should be used instead. * &lt;/p&gt; * * @param utteranceId The utterance ID of the utterance. * @param sampleRateInHz Sample rate in hertz of the generated audio. * @param audioFormat Audio format of the generated audio. Should be one of * {@link AudioFormat#ENCODING_PCM_8BIT}, {@link AudioFormat#ENCODING_PCM_16BIT} or * {@link AudioFormat#ENCODING_PCM_FLOAT}. * @param channelCount The number of channels. */ public void onBeginSynthesis(String utteranceId, int sampleRateInHz, int audioFormat, int channelCount) { } /** * This is called when a chunk of audio is ready for consumption. * * &lt;p&gt; * The audio parameter is a copy of what will be synthesized to the speakers (when synthesis was * initiated with a {@link TextToSpeech#speak} call) or written to the file system (for * {@link TextToSpeech#synthesizeToFile}). The audio bytes are delivered in one or more chunks; * if {@link #onDone} or {@link #onError} is called all chunks have been received. * &lt;/p&gt; * * &lt;p&gt; * The audio received here may not be played for some time depending on buffer sizes and the * amount of items on the synthesis queue. * &lt;/p&gt; * * @param utteranceId The utterance ID of the utterance. * @param audio A chunk of audio; the format can be known by listening to * {@link #onBeginSynthesis(String, int, int, int)}. */ public void onAudioAvailable(String utteranceId, byte[] audio) { } /** * This is called when the TTS service is about to speak the specified range of the utterance * with the given utteranceId. * * &lt;p&gt;This method is called when the audio is expected to start playing on the speaker. Note * that this is different from {@link #onAudioAvailable} which is called as soon as the audio is * generated. * &lt;p&gt;This information can be used, for example, to highlight ranges of the text while it is * spoken. * * &lt;p&gt;Only called if the engine supplies timing information by calling {@link * SynthesisCallback#rangeStart(int, int, int)}. * * @param utteranceId Unique id identifying the synthesis request. * @param start The start index of the range in the utterance text. * @param end The end index of the range (exclusive) in the utterance text. * @param frame The position in frames in the audio of the request where this range is spoken. */ public void onRangeStart(String utteranceId, int start, int end, int frame) { onUtteranceRangeStart(utteranceId, start, end); } /** @removed */ @Deprecated public void onUtteranceRangeStart(String utteranceId, int start, int end) { } /** * Wraps an old deprecated OnUtteranceCompletedListener with a shiny new progress listener. * * @hide */ static UtteranceProgressListener from( final TextToSpeech.OnUtteranceCompletedListener listener) { return new UtteranceProgressListener() { @Override public synchronized void onDone(String utteranceId) { listener.onUtteranceCompleted(utteranceId); } @Override public void onError(String utteranceId) { listener.onUtteranceCompleted(utteranceId); } @Override public void onStart(String utteranceId) { // Left unimplemented, has no equivalent in the old // API. } @Override public void onStop(String utteranceId, boolean interrupted) { listener.onUtteranceCompleted(utteranceId); } }; }}","link":"/2019/04/12/Android原生TTS逻辑分析的副本/"},{"title":"RxJava2 Official Document Note1","text":"针对ReactiveX官网给出的官方文档我做了翻译和总结性笔记 Observable被观察者在ReactiveX中,Observable称为被观察者,Observer称为观察者,subscribe称为订阅,emit称为发射,item成为项目,object称为对象,operator成为操作符。 观察者可以订阅被观察者。在观察者订阅了被观察者后,观察者可以对被观察者发射出来的任意项目和项目序列作出反应。这个模式促进了并发操作,因为整个过程（which）可以不被等待观察者发射对象的过程阻塞。这个模式是通过创建一个观察者形式的哨兵,他随时准备对被观察者未来可能作出的任何操作作出合适的反映。 这个页面解释了什么是反应模式（reactive pattern）,什么是观察者和被观察者,观察者怎样订阅被观察者,其他页面展示了你怎样使用各种被观察者操作符来将被观察者连接在一起并改变它们的行为。 这个文档结合大理石图（marble diagrams）和文字来作出解释,以下大理石图展示了被观察者和被观察者的转换过程： 这是被观察者的事件线,时间从左到右流动 这些是被观察者发射出来的项目 这个垂直的竖线表明被观察者已经成功发射完全部项目 这些带点的虚线和中间的方块盒子表明转换过程正在被应用于被观察者（发射的项目）身上。盒子内部中间的文字表明了转变的自然过程 这个被观察者就是转换的结果（即转换结果可以还是被观察者） 如果因为一些原因被观察者被异常终止,垂直的竖线将被一个X代替表示终止 你也可以看看:Single-一个特殊版本的观察者,它只发射一个项目Rx Workshop: IntroductionIntroduction to Rx: IObservableMastering observables (from the Couchbase Server documentation)2 minute introduction to Rx by Andre Staltz (“将被观察者看做一个异步的一成不变的序列。”)Introducing the Observable by Jafar Husain (JavaScript Video Tutorial)Observable object (RxJS) by Dennis StoyanovTurning a callback into an Rx Observable by @afterecho Backgroud后台在一些软件编程任务中,你或多或少的希望你写的说明将被一点点地,逐次递增地被执行和完善,并且按照你写的顺序那么去做。但是在ReactiveX中,一些说明可能是平行执行的,它们的结果随后会被观察者以随意的顺序捕获。比起调用一个方法,你用被观察者形式定义了一种检索和转变数据的机制,然后给它订阅一个观察者,在先前定义的机制,它会响应观察者哨兵的捕获并对被观察者无论何时发出的发射项目作出反应。 这种方式的一个优点是当你有一堆不相互依赖的任务时,你可以同时开始这些任务,而不是在开始下一个任务前要等待上一个任务完成。用这种方式,你这一捆任务的完成时间和这捆任务中耗时最长的任务完成时间相同。 这里有一些术语用来描述异步编程和设计的模型,这个文档将使用下列术语：一个订阅了被观察者的观察者,一个被观察者发射了一个项目或发送了一个通知给它们的观察者通过调用观察者的方法。 在其他的文档和内容中,我们称Observer为观察者,有时也叫它Subscriber订阅者,watcher监视者,reactor反应者,这个模型通常被称为reactor pattern反映者模式。 Establishing Observers创建观察者这页使用了类goorvy的伪代码来展示例子,但这些ReactiveX实现也在其他一些语言中。 在一个普通的方法调用中（也就是说并不像ReactiveX中那样异步并行的调用类型）,它的流是这样的： 调用一个方法 存储来自这个方法的返回值于一个变量中 使用这个变量和它的新值来作些有用的事情 在异步模型中方法流是这样的： 定义一个能用来自于异步调用的返回值做一些有用的事的方法,这个方法是观察者的一部分 定义一个异步调用它自己的实体叫被观察者 连接这个观察者和被观察者通过订阅它（这也叫做初始化被观察者的行为） 继续你的业务；无论什么时候异步调用有了返回值=结果,观察者的方法将开始针对返回值进行操作,这些项目就是由被观察着发射的 onNext,onCompleted,and onError处理每个异步返回值的方法,完成处理后调用的方法,出错时调用的方法订阅subscribe方法是你连接一个观察者和被观察者的方式。你的观察者实现了下列方法的子集： onNext处理每个异步返回值的方法一个被观察者调用这个方法在这个被观察者无论何时发射出一个项目的时候,这个方法将被观察者发出的项目作为参数 onCompleted完成处理后调用的方法被观察者调用这个方法当他调用了最后一次onNext方法,在被观察者整个过程没有遭遇到任何错误的情况下。 onError出错时调用的方法一个被观察者调用这个方法来表明它没能产生期望的数据或遭遇了其他一些错误,它将不能后续调用onNext和onCompleted方法onError方法用导致错误发生的原因作为它的参数 在对the Observable contract即一种对被观察者标准定义的尝试的术语定义中,它可能调用onNext零次和数次,然后可能调用onCompleted或onError中的一种作为被观察者调用的最后一次的方法,并不是两者都调用。按照惯例,在这个文档中,对onNext的调用通常为叫做项目的发射,而调用onCompleted和onError被叫做通知 也可以看看Introduction to Rx: IObserver Unsubscribing退订在一些ReactiveX实现中,有一种特殊的观察者接口,被称为subscriber订阅者,它实现了一个解除订阅的方法unsubscribe。你可以调用这个方法来表明这个订阅者不在对它当前订阅过的任何被观察者感兴趣。这些被观察者随后（如果它们没有其他感兴趣的观察者的话）会选择停止产生新项目去发射。 解除订阅的结果可能会层级反馈给反映者链,这些反映者是应用于那些已经实现了订阅关系的被观察者,然后这将导致链上的每一个连接停止发射项目。这并不能保证一切是立即发生的,然而,一个被观察者在即使没有观察者保留观察它们的发射项目的情况下依然产生和尝试发射项目一段时间是可能的。 Some Notes on Naming Conventions一些命名约定的备注每一种ReactiveX在特定语言上的实现都有自己的命名怪僻,这里没有典范的命名标准,尽管这里有一些实现上的共性。 此外,这些名称在其他情形中具有不同的含义,或者在特定实现语言的习语中看起来很尴尬。 例如onEvent这种命名模式（还有onNext,onCompleted,onError）。在一些情形下,这些名称指明方法通过事件处理者被注册的意义。在ReactiveX中,然而,他们表示事件处理者自己本身。 “HOt” and “Cold” Observable 热和冷被观察者什么时候被观察者开始发射项目的序列呢？这决定于被观察者。热观察者可能开始发射项目从它一被创建就开始,因此一些后来订阅了这个被观察者的观察者可能开始观察这个序列从中间的某个时候。冷被观察者,从另一方面说,在它开始发射项目之前它将一直等待直到一个观察者订阅了它。如此这样一个观察者被认为看到了整个序列从开始的过程。 在ReactiveX的一些实现中,有些概念被称为Connectable Obsevable可连接的被观察者。这种被观察者不会从一开始就发射项目直到它的connect连接方法被调用,无论它又没有被任何观察者订阅。 Composition via Observable Operators通过被观察者操作符进行组合被观察者和观察者只是ReactiveX的开始,她们自己本身不过是标准观察者模式的轻微扩展,为了更好的处理事件的序列而不是单个的回调。 真正的能力来自于反应性扩展（即ReactiveX）-操作符,它允许你转变,结合,操作,处理被观察者发射的项目序列。 这些Rx操作符允许你以声明的方式将异步序列组合在一起,拥有回调的所有效率优点,但没有嵌套回调处理者通常都与异步系统相关联的缺点。 这个文档组信息包括各种操作符和它们使用的的例子： 创造被观察者 create,defer,empty/never/throw,from,interval,just,range,repeat,start,timer 转变被观察者项目 buffer,flatmap,groupby,map,scan,window 过滤被观察者 debounce,distinct,elementat,filter,first,ignoreelements,last,sample,skip,skiplast,take,takelast 结合被观察者 and/then/when,combinelatest,join,merge,startwith,switch,zip 错误处理操作符 catch,retry 工具操作符 delay,do,materialize/dematerialize, observeon, serialize, subscribe, subscribeon, timeinterval, timeout, timestamp,using 条件判断布朗操作符 all,amb,contains,defaultifempty,sequenceequal,skipuntil,skipwhile,takeuntil,takewhile 数学与集合预算符 average,concat,count,max,min,reduce,sum 转换操作符 to 可连接的被观察者操作符 connect,publish,refcount,replay 背压操作符 各种操作符执行特定的流控制策略 这些页展示的关于一些操作符的信息不是ReactiveX核心的一部分,但是这些被实现在一种或多种特定语言的实现上或可选模块中。 Chaining Operators连接操作符大多数操作符操作于被观察者,并返回一个被观察者,这允许了你能够在调用链中一个接一个地应用这些操作符。每一个操作符都修改了传递到来自上一个操作符的操作过的被观察者。 这里还有其他一些模式,如建造者模式,一个特定类中的各种方法操作在同一个类的项目上,通过这些方法的操作可以些该这些对象。这种模式允许你连是串联起这些方法以同样的方式。但在建造者模式中,方法在链中出现的顺序不是很重要,但是被观察者操作符的顺序很重要。 被观察者操作符的链不能生效在一个原始的创造了这个链的被观察者上,它们是反过来操作的。在被观察者身上的每一个操作都产生于链上上一个操作符的操作结果。","link":"/2019/03/21/RxJava2 Official Document Note/"},{"title":"RxJava2 Official Document Note1","text":"针对ReactiveX官网给出的官方文档我做了翻译和总结性笔记 Observable被观察者在ReactiveX中,Observable称为被观察者,Observer称为观察者,subscribe称为订阅,emit称为发射,item成为项目,object称为对象,operator成为操作符。 观察者可以订阅被观察者。在观察者订阅了被观察者后,观察者可以对被观察者发射出来的任意项目和项目序列作出反应。这个模式促进了并发操作,因为整个过程（which）可以不被等待观察者发射对象的过程阻塞。这个模式是通过创建一个观察者形式的哨兵,他随时准备对被观察者未来可能作出的任何操作作出合适的反映。 这个页面解释了什么是反应模式（reactive pattern）,什么是观察者和被观察者,观察者怎样订阅被观察者,其他页面展示了你怎样使用各种被观察者操作符来将被观察者连接在一起并改变它们的行为。 这个文档结合大理石图（marble diagrams）和文字来作出解释,以下大理石图展示了被观察者和被观察者的转换过程： 这是被观察者的事件线,时间从左到右流动 这些是被观察者发射出来的项目 这个垂直的竖线表明被观察者已经成功发射完全部项目 这些带点的虚线和中间的方块盒子表明转换过程正在被应用于被观察者（发射的项目）身上。盒子内部中间的文字表明了转变的自然过程 这个被观察者就是转换的结果（即转换结果可以还是被观察者） 如果因为一些原因被观察者被异常终止,垂直的竖线将被一个X代替表示终止 你也可以看看:Single-一个特殊版本的观察者,它只发射一个项目Rx Workshop: IntroductionIntroduction to Rx: IObservableMastering observables (from the Couchbase Server documentation)2 minute introduction to Rx by Andre Staltz (“将被观察者看做一个异步的一成不变的序列。”)Introducing the Observable by Jafar Husain (JavaScript Video Tutorial)Observable object (RxJS) by Dennis StoyanovTurning a callback into an Rx Observable by @afterecho Backgroud后台在一些软件编程任务中,你或多或少的希望你写的说明将被一点点地,逐次递增地被执行和完善,并且按照你写的顺序那么去做。但是在ReactiveX中,一些说明可能是平行执行的,它们的结果随后会被观察者以随意的顺序捕获。比起调用一个方法,你用被观察者形式定义了一种检索和转变数据的机制,然后给它订阅一个观察者,在先前定义的机制,它会响应观察者哨兵的捕获并对被观察者无论何时发出的发射项目作出反应。 这种方式的一个优点是当你有一堆不相互依赖的任务时,你可以同时开始这些任务,而不是在开始下一个任务前要等待上一个任务完成。用这种方式,你这一捆任务的完成时间和这捆任务中耗时最长的任务完成时间相同。 这里有一些术语用来描述异步编程和设计的模型,这个文档将使用下列术语：一个订阅了被观察者的观察者,一个被观察者发射了一个项目或发送了一个通知给它们的观察者通过调用观察者的方法。 在其他的文档和内容中,我们称Observer为观察者,有时也叫它Subscriber订阅者,watcher监视者,reactor反应者,这个模型通常被称为reactor pattern反映者模式。 Establishing Observers创建观察者这页使用了类goorvy的伪代码来展示例子,但这些ReactiveX实现也在其他一些语言中。 在一个普通的方法调用中（也就是说并不像ReactiveX中那样异步并行的调用类型）,它的流是这样的： 调用一个方法 存储来自这个方法的返回值于一个变量中 使用这个变量和它的新值来作些有用的事情 在异步模型中方法流是这样的： 定义一个能用来自于异步调用的返回值做一些有用的事的方法,这个方法是观察者的一部分 定义一个异步调用它自己的实体叫被观察者 连接这个观察者和被观察者通过订阅它（这也叫做初始化被观察者的行为） 继续你的业务；无论什么时候异步调用有了返回值=结果,观察者的方法将开始针对返回值进行操作,这些项目就是由被观察着发射的 onNext,onCompleted,and onError处理每个异步返回值的方法,完成处理后调用的方法,出错时调用的方法订阅subscribe方法是你连接一个观察者和被观察者的方式。你的观察者实现了下列方法的子集： onNext处理每个异步返回值的方法一个被观察者调用这个方法在这个被观察者无论何时发射出一个项目的时候,这个方法将被观察者发出的项目作为参数 onCompleted完成处理后调用的方法被观察者调用这个方法当他调用了最后一次onNext方法,在被观察者整个过程没有遭遇到任何错误的情况下。 onError出错时调用的方法一个被观察者调用这个方法来表明它没能产生期望的数据或遭遇了其他一些错误,它将不能后续调用onNext和onCompleted方法onError方法用导致错误发生的原因作为它的参数 在对the Observable contract即一种对被观察者标准定义的尝试的术语定义中,它可能调用onNext零次和数次,然后可能调用onCompleted或onError中的一种作为被观察者调用的最后一次的方法,并不是两者都调用。按照惯例,在这个文档中,对onNext的调用通常为叫做项目的发射,而调用onCompleted和onError被叫做通知 也可以看看Introduction to Rx: IObserver Unsubscribing退订在一些ReactiveX实现中,有一种特殊的观察者接口,被称为subscriber订阅者,它实现了一个解除订阅的方法unsubscribe。你可以调用这个方法来表明这个订阅者不在对它当前订阅过的任何被观察者感兴趣。这些被观察者随后（如果它们没有其他感兴趣的观察者的话）会选择停止产生新项目去发射。 解除订阅的结果可能会层级反馈给反映者链,这些反映者是应用于那些已经实现了订阅关系的被观察者,然后这将导致链上的每一个连接停止发射项目。这并不能保证一切是立即发生的,然而,一个被观察者在即使没有观察者保留观察它们的发射项目的情况下依然产生和尝试发射项目一段时间是可能的。 Some Notes on Naming Conventions一些命名约定的备注每一种ReactiveX在特定语言上的实现都有自己的命名怪僻,这里没有典范的命名标准,尽管这里有一些实现上的共性。 此外,这些名称在其他情形中具有不同的含义,或者在特定实现语言的习语中看起来很尴尬。 例如onEvent这种命名模式（还有onNext,onCompleted,onError）。在一些情形下,这些名称指明方法通过事件处理者被注册的意义。在ReactiveX中,然而,他们表示事件处理者自己本身。 “HOt” and “Cold” Observable 热和冷被观察者什么时候被观察者开始发射项目的序列呢？这决定于被观察者。热观察者可能开始发射项目从它一被创建就开始,因此一些后来订阅了这个被观察者的观察者可能开始观察这个序列从中间的某个时候。冷被观察者,从另一方面说,在它开始发射项目之前它将一直等待直到一个观察者订阅了它。如此这样一个观察者被认为看到了整个序列从开始的过程。 在ReactiveX的一些实现中,有些概念被称为Connectable Obsevable可连接的被观察者。这种被观察者不会从一开始就发射项目直到它的connect连接方法被调用,无论它又没有被任何观察者订阅。 Composition via Observable Operators通过被观察者操作符进行组合被观察者和观察者只是ReactiveX的开始,她们自己本身不过是标准观察者模式的轻微扩展,为了更好的处理事件的序列而不是单个的回调。 真正的能力来自于反应性扩展（即ReactiveX）-操作符,它允许你转变,结合,操作,处理被观察者发射的项目序列。 这些Rx操作符允许你以声明的方式将异步序列组合在一起,拥有回调的所有效率优点,但没有嵌套回调处理者通常都与异步系统相关联的缺点。 这个文档组信息包括各种操作符和它们使用的的例子： 创造被观察者 create,defer,empty/never/throw,from,interval,just,range,repeat,start,timer 转变被观察者项目 buffer,flatmap,groupby,map,scan,window 过滤被观察者 debounce,distinct,elementat,filter,first,ignoreelements,last,sample,skip,skiplast,take,takelast 结合被观察者 and/then/when,combinelatest,join,merge,startwith,switch,zip 错误处理操作符 catch,retry 工具操作符 delay,do,materialize/dematerialize, observeon, serialize, subscribe, subscribeon, timeinterval, timeout, timestamp,using 条件判断布朗操作符 all,amb,contains,defaultifempty,sequenceequal,skipuntil,skipwhile,takeuntil,takewhile 数学与集合预算符 average,concat,count,max,min,reduce,sum 转换操作符 to 可连接的被观察者操作符 connect,publish,refcount,replay 背压操作符 各种操作符执行特定的流控制策略 这些页展示的关于一些操作符的信息不是ReactiveX核心的一部分,但是这些被实现在一种或多种特定语言的实现上或可选模块中。 Chaining Operators连接操作符大多数操作符操作于被观察者,并返回一个被观察者,这允许了你能够在调用链中一个接一个地应用这些操作符。每一个操作符都修改了传递到来自上一个操作符的操作过的被观察者。 这里还有其他一些模式,如建造者模式,一个特定类中的各种方法操作在同一个类的项目上,通过这些方法的操作可以些该这些对象。这种模式允许你连是串联起这些方法以同样的方式。但在建造者模式中,方法在链中出现的顺序不是很重要,但是被观察者操作符的顺序很重要。 被观察者操作符的链不能生效在一个原始的创造了这个链的被观察者上,它们是反过来操作的。在被观察者身上的每一个操作都产生于链上上一个操作符的操作结果。","link":"/2019/03/21/RxJava2 Official Document Note的副本/"},{"title":"RxJava学习笔记","text":"本文内容学习总结来自扔物线所写的给 Android 开发者的 RxJava 详解 什么是RxJava a library for composing asynchronous and event-based programs using observable sequences for the Java VM 即一个在Java虚拟机上使用了可观测序列的组合了异步和事件驱动的程序的库，RxJava的本质是一个实现异步操作的库, 优点是把复杂的业务逻辑变得简介，可读性强。 API介绍和原理简析RxJava 的异步实现，是通过一种扩展的观察者模式来实现的。 扩展的观察者模式在RxJava中，Observable被Observer所观察，通过subscribe()方法实现订阅。 RxJava 有四个基本概念：Observable (可观察者，即被观察者)、 Observer (观察者)、 subscribe (订阅)、事件 RxJava 的事件回调方法除了普通事件 onNext() 之外，还定义了两个特殊的事件：onCompleted() 和 onError()。 被观察者通过订阅被观察者监视，当触发订阅事件时，会回调onNext()等事件 基本实现RxJava 的基本实现主要有三点： 创建Observer观察者决定事件触发时将有怎样的行为。RxJava 中的 Observer 接口的实现方式： 12345678910111213141516Observer&lt;String&gt; observer = new Observer&lt;String&gt;() { @Override public void onNext(String s) { Log.d(tag, \"Item: \" + s); } @Override public void onCompleted() { Log.d(tag, \"Completed!\"); } @Override public void onError(Throwable e) { Log.d(tag, \"Error!\"); }}; RxJava 还内置了一个实现了 Observer 的抽象类：Subscriber。 Subscriber 对 Observer 接口进行了一些扩展，但他们的基本使用方式是完全一样的： 12345678910111213141516Subscriber&lt;String&gt; subscriber = new Subscriber&lt;String&gt;() { @Override public void onNext(String s) { Log.d(tag, \"Item: \" + s); } @Override public void onCompleted() { Log.d(tag, \"Completed!\"); } @Override public void onError(Throwable e) { Log.d(tag, \"Error!\"); }}; Observer 和 Subscriber的区别主要有两点： onStart() 这是 Subscriber 增加的方法。它会在 subscribe 刚开始，而事件还未发送之前被调用，可以用于做一些准备工作，例如数据的清零或重置。这是一个可选方法，默认情况下它的实现为空。需要注意的是，如果对准备工作的线程有要求（例如弹出一个显示进度的对话框，这必须在主线程执行）， onStart() 就不适用了，因为它总是在 subscribe 所发生的线程被调用，而不能指定线程。要在指定的线程来做准备工作，可以使用 doOnSubscribe() 方法，具体可以在后面的文中看到。 unsubscribe() 这是 Subscriber 所实现的另一个接口 Subscription 的方法，用于取消订阅。在这个方法被调用后，Subscriber 将不再接收事件。一般在这个方法调用前，可以使用 isUnsubscribed() 先判断一下状态。 unsubscribe() 这个方法很重要，因为在 subscribe() 之后， Observable 会持有 Subscriber 的引用，这个引用如果不能及时被释放，将有内存泄露的风险。所以最好保持一个原则：要在不再使用的时候尽快在合适的地方（例如 onPause() onStop() 等方法中）调用 unsubscribe() 来解除引用关系，以避免内存泄露的发生。 创建Observable被观察者决定什么时候触发事件和触发怎样的事件，RxJava 使用 create() 方法来创建一个 Observable ，并为它定义事件触发规则： 123456789Observable observable = Observable.create(new Observable.OnSubscribe&lt;String&gt;() { @Override public void call(Subscriber&lt;? super String&gt; subscriber) { subscriber.onNext(\"Hello\"); subscriber.onNext(\"Hi\"); subscriber.onNext(\"Aloha\"); subscriber.onCompleted(); }}); Subscribe(订阅)创建了 Observable 和 Observer 之后，再用 subscribe() 方法将它们联结起来。 123observable.subscribe(observer);// 或者：observable.subscribe(subscriber); 除了 subscribe(Observer) 和 subscribe(Subscriber) ，subscribe() 还支持不完整定义的回调，RxJava 会自动根据定义创建出 Subscriber 。 线程控制在不指定线程的情况下， RxJava 遵循的是线程不变的原则，即：在哪个线程调用 subscribe()，就在哪个线程生产事件；在哪个线程生产事件，就在哪个线程消费事件。如果需要切换线程，就需要用到 Scheduler （调度器）。 Schedulers.immediate(): 直接在当前线程运行，相当于不指定线程。这是默认的 Scheduler。 Schedulers.newThread(): 总是启用新线程，并在新线程执行操作。 Schedulers.io(): I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和 newThread() 差不多，区别在于 io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io() 比 newThread() 更有效率。不要把计算工作放在 io() 中，可以避免创建不必要的线程。 Schedulers.computation(): 计算所使用的 Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个 Scheduler 使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在 computation() 中，否则 I/O 操作的等待时间会浪费 CPU。 另外， Android 还有一个专用的 AndroidSchedulers.mainThread()，它指定的操作将在 Android 主线程运行。 123456789Observable.just(1, 2, 3, 4) .subscribeOn(Schedulers.io()) // 指定 subscribe() 发生在 IO 线程 .observeOn(AndroidSchedulers.mainThread()) // 指定 Subscriber 的回调发生在主线程 .subscribe(new Action1&lt;Integer&gt;() { @Override public void call(Integer number) { Log.d(tag, \"number:\" + number); } }); 这种在 subscribe() 之前写上两句 subscribeOn(Scheduler.io()) 和 observeOn(AndroidSchedulers.mainThread()) 的使用方式非常常见，它适用于多数的 『后台线程取数据，主线程显示』的程序策略。 例如在IO线程读取图片，在安卓主线程设置照片，即使加载图片耗费了几十甚至几百毫秒的时间，也不会造成丝毫界面的卡顿。 123456789101112131415161718192021222324252627int drawableRes = ...;ImageView imageView = ...;Observable.create(new OnSubscribe&lt;Drawable&gt;() { @Override public void call(Subscriber&lt;? super Drawable&gt; subscriber) { Drawable drawable = getTheme().getDrawable(drawableRes)); subscriber.onNext(drawable); subscriber.onCompleted(); }}).subscribeOn(Schedulers.io()) // 指定 subscribe() 发生在 IO 线程.observeOn(AndroidSchedulers.mainThread()) // 指定 Subscriber 的回调发生在主线程.subscribe(new Observer&lt;Drawable&gt;() { @Override public void onNext(Drawable drawable) { imageView.setImageDrawable(drawable); } @Override public void onCompleted() { } @Override public void onError(Throwable e) { Toast.makeText(activity, \"Error!\", Toast.LENGTH_SHORT).show(); }}); 变换所谓变换，就是将事件序列中的对象或整个序列进行加工处理，转换成不同的事件或事件序列. 例如将String类型的事件对象map为Bitmap类型： 12345678910111213Observable.just(\"images/logo.png\") // 输入类型 String .map(new Func1&lt;String, Bitmap&gt;() { @Override public Bitmap call(String filePath) { // 参数类型 String return getBitmapFromPath(filePath); // 返回类型 Bitmap } }) .subscribe(new Action1&lt;Bitmap&gt;() { @Override public void call(Bitmap bitmap) { // 参数类型 Bitmap showBitmap(bitmap); } }); rx.Observable的map方法参数为Func1，与Action1类似，也是RxJava的一个接口，用于包装一个含有参数的方法。 Func1 和 Action 的区别在于， Func1 包装的是有返回值的方法。和 ActionX 一样， FuncX 也有多个，用于不同参数个数的方法。FuncX 和 ActionX 的区别在 FuncX 包装的是有返回值的方法。 常用变换： map(): 事件对象的直接变换 flatMap(): 将事件对象的多个成员变量发送给subscriber的回调方法 flatMap() 中返回的是个 Observable 对象，并且这个 Observable 对象并不是被直接发送到了 Subscriber 的回调方法中。 flatMap() 的原理是这样的：1. 使用传入的事件对象创建一个 Observable 对象；2. 并不发送这个 Observable, 而是将它激活，于是它开始发送事件；3. 每一个创建出来的 Observable 发送的事件，都被汇入同一个 Observable ，而这个 Observable 负责将这些事件统一交给 Subscriber 的回调方法。这三个步骤，把事件拆成了两级，通过一组新创建的 Observable 将初始的对象『铺平』之后通过统一路径分发了下去。而这个『铺平』就是 flatMap() 所谓的 flat。 变换的原理这些变换虽然功能各有不同，但实质上都是针对事件序列的处理和再发送。而在 RxJava 的内部，它们是基于同一个基础的变换方法： lift(Operator)。首先看一下 lift() 的内部实现（仅核心代码）： 123456789101112// 注意：这不是 lift() 的源码，而是将源码中与性能、兼容性、扩展性有关的代码剔除后的核心代码。// 如果需要看源码，可以去 RxJava 的 GitHub 仓库下载。public &lt;R&gt; Observable&lt;R&gt; lift(Operator&lt;? extends R, ? super T&gt; operator) { return Observable.create(new OnSubscribe&lt;R&gt;() { @Override public void call(Subscriber subscriber) { Subscriber newSubscriber = operator.call(subscriber); newSubscriber.onStart(); onSubscribe.call(newSubscriber); } });} 这段代码很有意思：它生成了一个新的 Observable 并返回，而且创建新 Observable 所用的参数 OnSubscribe 的回调方法 call() 中的实现竟然看起来和前面讲过的 Observable.subscribe() 一样！然而它们并不一样哟~不一样的地方关键就在于第二行 onSubscribe.call(subscriber) 中的 onSubscribe 所指代的对象不同（高能预警：接下来的几句话可能会导致身体的严重不适）—— subscribe() 中这句话的 onSubscribe 指的是 Observable 中的 onSubscribe 对象，这个没有问题，但是 lift() 之后的情况就复杂了点。 当含有 lift() 时： lift() 创建了一个 Observable 后，加上之前的原始 Observable，已经有两个 Observable 了； 而同样地，新 Observable 里的新 OnSubscribe 加上之前的原始 Observable 中的原始 OnSubscribe，也就有了两个 OnSubscribe； 当用户调用经过 lift() 后的 Observable 的 subscribe() 的时候，使用的是 lift() 所返回的新的 Observable ，于是它所触发的 onSubscribe.call(subscriber)，也是用的新 Observable 中的新 OnSubscribe，即在 lift() 中生成的那个 OnSubscribe； 而这个新 OnSubscribe 的 call() 方法中的 onSubscribe ，就是指的原始 Observable 中的原始 OnSubscribe ，在这个 call() 方法里，新 OnSubscribe 利用 operator.call(subscriber) 生成了一个新的 Subscriber（Operator 就是在这里，通过自己的 call() 方法将新 Subscriber 和原始 Subscriber 进行关联，并插入自己的『变换』代码以实现变换），然后利用这个新 Subscriber 向原始 Observable 进行订阅。 这样就实现了 lift() 过程，有点像一种代理机制，通过事件拦截和处理实现事件序列的变换。 compose: 对Observable整体的转换12345678910111213141516public class LiftAllTransformer implements Observable.Transformer&lt;Integer, String&gt; { @Override public Observable&lt;String&gt; call(Observable&lt;Integer&gt; observable) { return observable .lift1() .lift2() .lift3() .lift4(); }}...Transformer liftAll = new LiftAllTransformer();observable1.compose(liftAll).subscribe(subscriber1);observable2.compose(liftAll).subscribe(subscriber2);observable3.compose(liftAll).subscribe(subscriber3);observable4.compose(liftAll).subscribe(subscriber4); 使用 compose() 方法，Observable 可以利用传入的 Transformer 对象的 call 方法直接对自身进行处理，也就不必被包在方法的里面了。 线程控制： Schedule12345678Observable.just(1, 2, 3, 4) // IO 线程，由 subscribeOn() 指定 .subscribeOn(Schedulers.io()) .observeOn(Schedulers.newThread()) .map(mapOperator) // 新线程，由 observeOn() 指定 .observeOn(Schedulers.io()) .map(mapOperator2) // IO 线程，由 observeOn() 指定 .observeOn(AndroidSchedulers.mainThread) .subscribe(subscriber); // Android 主线程，由 observeOn() 指定 延伸：doOnSubscribe()而与 Subscriber.onStart() 相对应的，有一个方法 Observable.doOnSubscribe() 。它和 Subscriber.onStart() 同样是在 subscribe() 调用后而且在事件发送前执行，但区别在于它可以指定线程。默认情况下， doOnSubscribe() 执行在 subscribe() 发生的线程；而如果在 doOnSubscribe() 之后有 subscribeOn() 的话，它将执行在离它最近的 subscribeOn() 所指定的线程。 例如： 1234567891011Observable.create(onSubscribe) .subscribeOn(Schedulers.io()) .doOnSubscribe(new Action0() { @Override public void call() { progressBar.setVisibility(View.VISIBLE); // 需要在主线程执行 } }) .subscribeOn(AndroidSchedulers.mainThread()) // 指定主线程 .observeOn(AndroidSchedulers.mainThread()) .subscribe(subscriber); 如上，在 doOnSubscribe()的后面跟一个 subscribeOn() ，就能指定准备工作的线程了。 RxJava 的适用场景和使用方式与Retrofit结合 Retrofit 是 Square 的一个著名的网络请求库。 使用 RxJava 形式的 API，定义同样的请求是这样的： 12@GET(\"/user\")public Observable&lt;User&gt; getUser(@Query(\"userId\") String userId); 使用的时候是这样的： 123456789101112131415161718getUser(userId) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Observer&lt;User&gt;() { @Override public void onNext(User user) { userView.setUser(user); } @Override public void onCompleted() { } @Override public void onError(Throwable error) { // Error handling ... } });","link":"/2018/10/06/RxJava学习笔记/"},{"title":"RxJava学习笔记","text":"本文内容学习总结来自扔物线所写的给 Android 开发者的 RxJava 详解 什么是RxJava a library for composing asynchronous and event-based programs using observable sequences for the Java VM 即一个在Java虚拟机上使用了可观测序列的组合了异步和事件驱动的程序的库，RxJava的本质是一个实现异步操作的库, 优点是把复杂的业务逻辑变得简介，可读性强。 API介绍和原理简析RxJava 的异步实现，是通过一种扩展的观察者模式来实现的。 扩展的观察者模式在RxJava中，Observable被Observer所观察，通过subscribe()方法实现订阅。 RxJava 有四个基本概念：Observable (可观察者，即被观察者)、 Observer (观察者)、 subscribe (订阅)、事件 RxJava 的事件回调方法除了普通事件 onNext() 之外，还定义了两个特殊的事件：onCompleted() 和 onError()。 被观察者通过订阅被观察者监视，当触发订阅事件时，会回调onNext()等事件 基本实现RxJava 的基本实现主要有三点： 创建Observer观察者决定事件触发时将有怎样的行为。RxJava 中的 Observer 接口的实现方式： 12345678910111213141516Observer&lt;String&gt; observer = new Observer&lt;String&gt;() { @Override public void onNext(String s) { Log.d(tag, \"Item: \" + s); } @Override public void onCompleted() { Log.d(tag, \"Completed!\"); } @Override public void onError(Throwable e) { Log.d(tag, \"Error!\"); }}; RxJava 还内置了一个实现了 Observer 的抽象类：Subscriber。 Subscriber 对 Observer 接口进行了一些扩展，但他们的基本使用方式是完全一样的： 12345678910111213141516Subscriber&lt;String&gt; subscriber = new Subscriber&lt;String&gt;() { @Override public void onNext(String s) { Log.d(tag, \"Item: \" + s); } @Override public void onCompleted() { Log.d(tag, \"Completed!\"); } @Override public void onError(Throwable e) { Log.d(tag, \"Error!\"); }}; Observer 和 Subscriber的区别主要有两点： onStart() 这是 Subscriber 增加的方法。它会在 subscribe 刚开始，而事件还未发送之前被调用，可以用于做一些准备工作，例如数据的清零或重置。这是一个可选方法，默认情况下它的实现为空。需要注意的是，如果对准备工作的线程有要求（例如弹出一个显示进度的对话框，这必须在主线程执行）， onStart() 就不适用了，因为它总是在 subscribe 所发生的线程被调用，而不能指定线程。要在指定的线程来做准备工作，可以使用 doOnSubscribe() 方法，具体可以在后面的文中看到。 unsubscribe() 这是 Subscriber 所实现的另一个接口 Subscription 的方法，用于取消订阅。在这个方法被调用后，Subscriber 将不再接收事件。一般在这个方法调用前，可以使用 isUnsubscribed() 先判断一下状态。 unsubscribe() 这个方法很重要，因为在 subscribe() 之后， Observable 会持有 Subscriber 的引用，这个引用如果不能及时被释放，将有内存泄露的风险。所以最好保持一个原则：要在不再使用的时候尽快在合适的地方（例如 onPause() onStop() 等方法中）调用 unsubscribe() 来解除引用关系，以避免内存泄露的发生。 创建Observable被观察者决定什么时候触发事件和触发怎样的事件，RxJava 使用 create() 方法来创建一个 Observable ，并为它定义事件触发规则： 123456789Observable observable = Observable.create(new Observable.OnSubscribe&lt;String&gt;() { @Override public void call(Subscriber&lt;? super String&gt; subscriber) { subscriber.onNext(\"Hello\"); subscriber.onNext(\"Hi\"); subscriber.onNext(\"Aloha\"); subscriber.onCompleted(); }}); Subscribe(订阅)创建了 Observable 和 Observer 之后，再用 subscribe() 方法将它们联结起来。 123observable.subscribe(observer);// 或者：observable.subscribe(subscriber); 除了 subscribe(Observer) 和 subscribe(Subscriber) ，subscribe() 还支持不完整定义的回调，RxJava 会自动根据定义创建出 Subscriber 。 线程控制在不指定线程的情况下， RxJava 遵循的是线程不变的原则，即：在哪个线程调用 subscribe()，就在哪个线程生产事件；在哪个线程生产事件，就在哪个线程消费事件。如果需要切换线程，就需要用到 Scheduler （调度器）。 Schedulers.immediate(): 直接在当前线程运行，相当于不指定线程。这是默认的 Scheduler。 Schedulers.newThread(): 总是启用新线程，并在新线程执行操作。 Schedulers.io(): I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和 newThread() 差不多，区别在于 io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io() 比 newThread() 更有效率。不要把计算工作放在 io() 中，可以避免创建不必要的线程。 Schedulers.computation(): 计算所使用的 Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个 Scheduler 使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在 computation() 中，否则 I/O 操作的等待时间会浪费 CPU。 另外， Android 还有一个专用的 AndroidSchedulers.mainThread()，它指定的操作将在 Android 主线程运行。 123456789Observable.just(1, 2, 3, 4) .subscribeOn(Schedulers.io()) // 指定 subscribe() 发生在 IO 线程 .observeOn(AndroidSchedulers.mainThread()) // 指定 Subscriber 的回调发生在主线程 .subscribe(new Action1&lt;Integer&gt;() { @Override public void call(Integer number) { Log.d(tag, \"number:\" + number); } }); 这种在 subscribe() 之前写上两句 subscribeOn(Scheduler.io()) 和 observeOn(AndroidSchedulers.mainThread()) 的使用方式非常常见，它适用于多数的 『后台线程取数据，主线程显示』的程序策略。 例如在IO线程读取图片，在安卓主线程设置照片，即使加载图片耗费了几十甚至几百毫秒的时间，也不会造成丝毫界面的卡顿。 123456789101112131415161718192021222324252627int drawableRes = ...;ImageView imageView = ...;Observable.create(new OnSubscribe&lt;Drawable&gt;() { @Override public void call(Subscriber&lt;? super Drawable&gt; subscriber) { Drawable drawable = getTheme().getDrawable(drawableRes)); subscriber.onNext(drawable); subscriber.onCompleted(); }}).subscribeOn(Schedulers.io()) // 指定 subscribe() 发生在 IO 线程.observeOn(AndroidSchedulers.mainThread()) // 指定 Subscriber 的回调发生在主线程.subscribe(new Observer&lt;Drawable&gt;() { @Override public void onNext(Drawable drawable) { imageView.setImageDrawable(drawable); } @Override public void onCompleted() { } @Override public void onError(Throwable e) { Toast.makeText(activity, \"Error!\", Toast.LENGTH_SHORT).show(); }}); 变换所谓变换，就是将事件序列中的对象或整个序列进行加工处理，转换成不同的事件或事件序列. 例如将String类型的事件对象map为Bitmap类型： 12345678910111213Observable.just(\"images/logo.png\") // 输入类型 String .map(new Func1&lt;String, Bitmap&gt;() { @Override public Bitmap call(String filePath) { // 参数类型 String return getBitmapFromPath(filePath); // 返回类型 Bitmap } }) .subscribe(new Action1&lt;Bitmap&gt;() { @Override public void call(Bitmap bitmap) { // 参数类型 Bitmap showBitmap(bitmap); } }); rx.Observable的map方法参数为Func1，与Action1类似，也是RxJava的一个接口，用于包装一个含有参数的方法。 Func1 和 Action 的区别在于， Func1 包装的是有返回值的方法。和 ActionX 一样， FuncX 也有多个，用于不同参数个数的方法。FuncX 和 ActionX 的区别在 FuncX 包装的是有返回值的方法。 常用变换： map(): 事件对象的直接变换 flatMap(): 将事件对象的多个成员变量发送给subscriber的回调方法 flatMap() 中返回的是个 Observable 对象，并且这个 Observable 对象并不是被直接发送到了 Subscriber 的回调方法中。 flatMap() 的原理是这样的：1. 使用传入的事件对象创建一个 Observable 对象；2. 并不发送这个 Observable, 而是将它激活，于是它开始发送事件；3. 每一个创建出来的 Observable 发送的事件，都被汇入同一个 Observable ，而这个 Observable 负责将这些事件统一交给 Subscriber 的回调方法。这三个步骤，把事件拆成了两级，通过一组新创建的 Observable 将初始的对象『铺平』之后通过统一路径分发了下去。而这个『铺平』就是 flatMap() 所谓的 flat。 变换的原理这些变换虽然功能各有不同，但实质上都是针对事件序列的处理和再发送。而在 RxJava 的内部，它们是基于同一个基础的变换方法： lift(Operator)。首先看一下 lift() 的内部实现（仅核心代码）： 123456789101112// 注意：这不是 lift() 的源码，而是将源码中与性能、兼容性、扩展性有关的代码剔除后的核心代码。// 如果需要看源码，可以去 RxJava 的 GitHub 仓库下载。public &lt;R&gt; Observable&lt;R&gt; lift(Operator&lt;? extends R, ? super T&gt; operator) { return Observable.create(new OnSubscribe&lt;R&gt;() { @Override public void call(Subscriber subscriber) { Subscriber newSubscriber = operator.call(subscriber); newSubscriber.onStart(); onSubscribe.call(newSubscriber); } });} 这段代码很有意思：它生成了一个新的 Observable 并返回，而且创建新 Observable 所用的参数 OnSubscribe 的回调方法 call() 中的实现竟然看起来和前面讲过的 Observable.subscribe() 一样！然而它们并不一样哟~不一样的地方关键就在于第二行 onSubscribe.call(subscriber) 中的 onSubscribe 所指代的对象不同（高能预警：接下来的几句话可能会导致身体的严重不适）—— subscribe() 中这句话的 onSubscribe 指的是 Observable 中的 onSubscribe 对象，这个没有问题，但是 lift() 之后的情况就复杂了点。 当含有 lift() 时： lift() 创建了一个 Observable 后，加上之前的原始 Observable，已经有两个 Observable 了； 而同样地，新 Observable 里的新 OnSubscribe 加上之前的原始 Observable 中的原始 OnSubscribe，也就有了两个 OnSubscribe； 当用户调用经过 lift() 后的 Observable 的 subscribe() 的时候，使用的是 lift() 所返回的新的 Observable ，于是它所触发的 onSubscribe.call(subscriber)，也是用的新 Observable 中的新 OnSubscribe，即在 lift() 中生成的那个 OnSubscribe； 而这个新 OnSubscribe 的 call() 方法中的 onSubscribe ，就是指的原始 Observable 中的原始 OnSubscribe ，在这个 call() 方法里，新 OnSubscribe 利用 operator.call(subscriber) 生成了一个新的 Subscriber（Operator 就是在这里，通过自己的 call() 方法将新 Subscriber 和原始 Subscriber 进行关联，并插入自己的『变换』代码以实现变换），然后利用这个新 Subscriber 向原始 Observable 进行订阅。 这样就实现了 lift() 过程，有点像一种代理机制，通过事件拦截和处理实现事件序列的变换。 compose: 对Observable整体的转换12345678910111213141516public class LiftAllTransformer implements Observable.Transformer&lt;Integer, String&gt; { @Override public Observable&lt;String&gt; call(Observable&lt;Integer&gt; observable) { return observable .lift1() .lift2() .lift3() .lift4(); }}...Transformer liftAll = new LiftAllTransformer();observable1.compose(liftAll).subscribe(subscriber1);observable2.compose(liftAll).subscribe(subscriber2);observable3.compose(liftAll).subscribe(subscriber3);observable4.compose(liftAll).subscribe(subscriber4); 使用 compose() 方法，Observable 可以利用传入的 Transformer 对象的 call 方法直接对自身进行处理，也就不必被包在方法的里面了。 线程控制： Schedule12345678Observable.just(1, 2, 3, 4) // IO 线程，由 subscribeOn() 指定 .subscribeOn(Schedulers.io()) .observeOn(Schedulers.newThread()) .map(mapOperator) // 新线程，由 observeOn() 指定 .observeOn(Schedulers.io()) .map(mapOperator2) // IO 线程，由 observeOn() 指定 .observeOn(AndroidSchedulers.mainThread) .subscribe(subscriber); // Android 主线程，由 observeOn() 指定 延伸：doOnSubscribe()而与 Subscriber.onStart() 相对应的，有一个方法 Observable.doOnSubscribe() 。它和 Subscriber.onStart() 同样是在 subscribe() 调用后而且在事件发送前执行，但区别在于它可以指定线程。默认情况下， doOnSubscribe() 执行在 subscribe() 发生的线程；而如果在 doOnSubscribe() 之后有 subscribeOn() 的话，它将执行在离它最近的 subscribeOn() 所指定的线程。 例如： 1234567891011Observable.create(onSubscribe) .subscribeOn(Schedulers.io()) .doOnSubscribe(new Action0() { @Override public void call() { progressBar.setVisibility(View.VISIBLE); // 需要在主线程执行 } }) .subscribeOn(AndroidSchedulers.mainThread()) // 指定主线程 .observeOn(AndroidSchedulers.mainThread()) .subscribe(subscriber); 如上，在 doOnSubscribe()的后面跟一个 subscribeOn() ，就能指定准备工作的线程了。 RxJava 的适用场景和使用方式与Retrofit结合 Retrofit 是 Square 的一个著名的网络请求库。 使用 RxJava 形式的 API，定义同样的请求是这样的： 12@GET(\"/user\")public Observable&lt;User&gt; getUser(@Query(\"userId\") String userId); 使用的时候是这样的： 123456789101112131415161718getUser(userId) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Observer&lt;User&gt;() { @Override public void onNext(User user) { userView.setUser(user); } @Override public void onCompleted() { } @Override public void onError(Throwable error) { // Error handling ... } });","link":"/2018/10/06/RxJava学习笔记的副本/"},{"title":"《Java编程思想》读书笔记(第十五章)","text":"范型实现了参数化类型的概念，使得代码可以应用于多种类型 范型这个术语的意思是适用于许多许多的类型 简单范型范型出现的一个重要原因是为了创造容器类，容器就是存放要使用的对象的地方 只持有一个对象的类 123456789101112131415class Automobile{}public class Holder1{ private Automobile a; public Holder1(Automobile a){ this.a=a; } Automobile get(){ return a; }} 在Java SE5之前，可以让这个类直接持有Object类型的对象 1234567891011121314151617181920public class Holder2{private Object o;public Holder2(Object o){this.o=o;}public void set(Object o){this.o=o;}public Object get(){return o;}public static void main(String[] args){ Holder2 h2=new Holder2(new Automobile()); Automobile a=(Automobile)h2.get(); h2.set(\"did you miss me?\"); String s=(String)h2.get(); h2.set(1); Integer x=(Integer)h2.get();}} 范型的主要目的之一就是要指定容器要持有什么类型的对象，而且由编译器来保证类型的正确性 因此，与其使用Object，不如暂时不指定类型，而是在稍后使用的时候再指定具体用什么类型。要达到这个目的，需要使用类型参数，用尖括号括住，放在类名后面。然后在使用这个类的时候，在用实际的类型替换此类型参数。 12345678910public class Holder3&lt;T&gt;{private T a;public Holder3(T a){this.a=a;}public void set(T a){this.a=a;}public T get(){return a;}public static void main(String[] args){ Holder3&lt;Automobile&gt; h3=new Holder3&lt;Automobile&gt;(new Automobile()); Automobile a=(Automobile)h3.get();//no cast need}} 一个元组类库元组将一组对象直接打包储存于其中的一个单一对象 123456789101112public class TwoTuple&lt;A,B&gt;{public final A first;public final B second;public TwoTuple(A a,B b){first=a;second=b;}public String toString(){ return \"(\"+first+\",\"+second+\")\";}} 我们可以通过继承机制实现长度更长的元组 1234567891011121314public class ThreeTuple&lt;A,B,C&gt; extends TwoTuple&lt;A,B&gt;{public final C third;public ThreeTuple(A a,B b,C c){super(a,b);third=c;}public String toString(){return \"(\"+first+\",\"+second+\",\"+third+\")\";}} 为了使用元组，只需定义一个长度合适的元组，将其作为方法的返回值，然后在return语句中创建该元组并返回即可 在对象被构造出来后，声明为final的元素便不能被赋予其他的值了 一个堆栈类123456789101112131415161718192021222324252627282930313233public class LinkedStack&lt;T&gt;{ private static class Node&lt;U&gt;{ U item; Node&lt;U&gt; next; Node(){item=null;next=null;} Node(U item,Node&lt;U&gt; next){this.item=item;this.next=next;} boolean end(){return item == null &amp;&amp; next == null;} } private Node&lt;T&gt; top=new Node&lt;T&gt;(); public void push(T item){ top=new Node&lt;T&gt;(item,top); } public T pop(){ T result=top.item; if(!top.end()){ top=top.next; } return result; } public static void main(String[] args){ LinkedStack&lt;String&gt; lss=new LinkedStack&lt;String&gt;(); for(String s:\"Are you ok\".split){ lss.push(s); } String s; while((s=lss.pop())!=null) System.out.println(s); }} 这个例子使用末端哨兵（end sentinel）来判读堆栈何时为空。这个末端哨兵是在构造LinkedStack时创建的 RandomList就是一个范型类里包含了一个ArrayList，随机选择一个对象 范型接口范型也可以应用于接口 1public interface Generator&lt;T&gt;{T next();} 基本类型无法作为类型参数 1234567891011121314151617public class Fibonacci implements Generator&lt;Integer&gt;{ private int count=0; public Integer next(){return fib(count++)} private int fib(int n){ if(n&lt;2) return 1; return fib(n-1)+fib(n-2); } public static void main(String[] args){ Fibonacci gen=new Fabonacci(); for(int i=0;i&lt;11;i++){ syso(gen.next()+\" \"); } }} 范型方法范型可以用于整个类之上，也可以在类中包含参数化方法 是否拥有范型方法，与其所在的类是否是范型没有关系 定义范型方法，只需将范型参数列表置于返回值之前 12345public class GenericMethod{ public &lt;T&gt; void f(T x){ System.out.println(x.getClass().getName()); }} 方法拥有的参数类型，是由该方法的返回值类型前面的类型参数决定的 当使用范型类是，必须在创建对象时指定类型参数的值，而在使用范型方法时通常不必指明参数类型，因为编译器辉为我们找到具体的类型，这叫做类型参数推断(type argument inference) 我们可以像调用普通方法一样调用范型方法，就好像该方法被无限次地重载过 如果调用范型方法时传入了基本类型，自动打包机制就会介入其中，将基本类型的值包装为对应的对象 杠杆利用类型参数推断类型推断支队赋值操作有效 显式的类型说明 在范型方法中可以显示的指明类型，要显式的指明类型，必须在点操作符和方法名之间插入尖括号，然后把类型置入尖括号内，如果是在定义该方法的类的内部，必须在点操作符之前使用this关键字，如果是static方法，必须在点操作符之前加上类名 123456public class ExplicitTypeSpcification{ static void f(Map&lt;Person,List&lt;Pet&gt;&gt; petPeople){} public static void main(String[] args){ f(New.&lt;Persom,List&lt;Pet&gt;&gt;map()); }} 只有编写非赋值语句时，我们才需要这样额外的说明 可变参数和范型方法范型方法和可变参数列表可以很好的共存 123456789public class GenericVarargs{ public static &lt;T&gt; List&lt;T&gt; makeList(T...args){ List&lt;T&gt; result=new ArrayList&lt;T&gt;(); for(T item:args) result.add(item); return result; }} makeList()方法展示了和标准类库中的java.util.Arrays.asList()方法相同的功能 一个set实用工具作为范型方法的示例，set可以表达数学中的关系式,表达元素的并，交等运算 12345678910111213141516171819202122232425public class Sets{ public static &lt;T&gt; Set&lt;T&gt; union(Set&lt;T&gt; a,Set&lt;T&gt; b){ Set&lt;T&gt; result=new HashSet&lt;T&gt;(a); result.addAll(b); return result; } public static &lt;T&gt; Set&lt;T&gt; intersection(Set&lt;T&gt; a,Set&lt;T&gt; b){ Set&lt;T&gt; result= new HashSet&lt;T&gt;(a); result.retainAll(b); return result; } public static &lt;T&gt; Set&lt;T&gt; difference(Set&lt;T&gt; a,Set&lt;T&gt; b){ Set&lt;T&gt; result=new HashSet&lt;T&gt;(a); result.removeAll(b); return result; } public static &lt;T&gt; Set&lt;T&gt; complement(Set&lt;T&gt; a,Set&lt;T&gt; b){ return difference(union(a,b),intersection(a,b)); }} EnumSet是Java SE5中的新工具，用来从enum直接创建Set，其静态方法EnumSet.range()可以传入某个范围内的第一个元素和最后一个元素，然后它将返回一个set，包含该范围内的所有元素 1234567public enum Watercolor{ZINC,LEMON_YELLOW,....}public class WatercolorSets{Set&lt;Watercolors&gt; sets1 =EnumSet.range(ZINC,LEMON_YELLOW);} 匿名内部类范型可以应用于内部类及匿名内部类 构建复杂模型范型的一个重要好处是能够简单而安全的创建复杂模型 擦除的神秘之处同一种类的不同范型对象，通过getClass()得到的Class对象是相同的 根据JDK文档的描述，Class.getTypeParameters()将返回一个类型参数对象数组，表明有范型声明的类型参数。 在范型代码内部，无法获得任何有关范型参数类型的信息 Java范型是使用范擦除来实现的，这意味着你在使用范型时，任何具体的类型信息都被擦除了，你唯一知道的是你在使用一个对象 C++的方式java的范型是受C++启发的 在C++中，Manipulator类存储了一个类型T的对象，其方法调用了f()，因为C++的范型语法和Java有区别，在实例化这个模板时，C++编译器将进行检查，因此在该类被实例化的这一刻，它会看到HasF有一个方法f() 123456789101112131415161718192021#include &lt;iostream&gt;using namespace std;template&lt;class T&gt; class Manipulator{ T obj; public: Manipulator(T x){obj=x;} void manipulate{obj.f();}};class HasF{ public: void f(){cout&lt;&lt;\"hasF::f()\"&lt;&lt;endl;}};int main(){ HasF hf; Manipulator&lt;HasF&gt; manipulator(hf); manipulator.manipulate();} 而在Java上由于范型的擦除机制，Java编译器将manipulate()必须能够在obj上调用f()的这一需求映射到HasF拥有f()这一事实上，为类调用f()，我们必须协助范型类，给定范型类的边界，以此告知编译器只能接受这个边界的类型，这里是重用了extends关键字 1234567891011//octopusheep/HasF.javapublic class HasF{ public void f(){System.out.println(\"HasF.f()\");}}//octopusheep/Manipulation.javaclass Manipulator&lt;T extends HasF&gt;{ private T obj; Manipulator(T X){obj=x;} public void manipulate(){obj.f();}} 边界声明了T必须具有类型HasF或HasF导出的类型，这样就可以安全的在obj上调用f()了 迁移兼容性擦除的核心动机是它使得泛化的客户端可以使用非泛化的类库，反之亦然，这经常被成为”迁移兼容性” 擦除的问题为了关闭警告，Java提供了一个注解，这个注解在Java SE5之前的版本中不支持 1@SuppressWarnings(\"unchecked\") 边界处的动作对于在范型中创建数组，使用Array.newInstance()是推荐方式 通配符通配符允许在两个类型之间建立某种类型的向上转型关系 问题基本类型不能被当作参数类型 一个类不能实现同一个范型接口的两种变体","link":"/2019/04/30/《Java编程思想》读书笔记(第十五章)/"},{"title":"《Java编程思想》读书笔记(第十五章)","text":"范型实现了参数化类型的概念，使得代码可以应用于多种类型 范型这个术语的意思是适用于许多许多的类型 简单范型范型出现的一个重要原因是为了创造容器类，容器就是存放要使用的对象的地方 只持有一个对象的类 123456789101112131415class Automobile{}public class Holder1{ private Automobile a; public Holder1(Automobile a){ this.a=a; } Automobile get(){ return a; }} 在Java SE5之前，可以让这个类直接持有Object类型的对象 1234567891011121314151617181920public class Holder2{private Object o;public Holder2(Object o){this.o=o;}public void set(Object o){this.o=o;}public Object get(){return o;}public static void main(String[] args){ Holder2 h2=new Holder2(new Automobile()); Automobile a=(Automobile)h2.get(); h2.set(\"did you miss me?\"); String s=(String)h2.get(); h2.set(1); Integer x=(Integer)h2.get();}} 范型的主要目的之一就是要指定容器要持有什么类型的对象，而且由编译器来保证类型的正确性 因此，与其使用Object，不如暂时不指定类型，而是在稍后使用的时候再指定具体用什么类型。要达到这个目的，需要使用类型参数，用尖括号括住，放在类名后面。然后在使用这个类的时候，在用实际的类型替换此类型参数。 12345678910public class Holder3&lt;T&gt;{private T a;public Holder3(T a){this.a=a;}public void set(T a){this.a=a;}public T get(){return a;}public static void main(String[] args){ Holder3&lt;Automobile&gt; h3=new Holder3&lt;Automobile&gt;(new Automobile()); Automobile a=(Automobile)h3.get();//no cast need}} 一个元组类库元组将一组对象直接打包储存于其中的一个单一对象 123456789101112public class TwoTuple&lt;A,B&gt;{public final A first;public final B second;public TwoTuple(A a,B b){first=a;second=b;}public String toString(){ return \"(\"+first+\",\"+second+\")\";}} 我们可以通过继承机制实现长度更长的元组 1234567891011121314public class ThreeTuple&lt;A,B,C&gt; extends TwoTuple&lt;A,B&gt;{public final C third;public ThreeTuple(A a,B b,C c){super(a,b);third=c;}public String toString(){return \"(\"+first+\",\"+second+\",\"+third+\")\";}} 为了使用元组，只需定义一个长度合适的元组，将其作为方法的返回值，然后在return语句中创建该元组并返回即可 在对象被构造出来后，声明为final的元素便不能被赋予其他的值了 一个堆栈类123456789101112131415161718192021222324252627282930313233public class LinkedStack&lt;T&gt;{ private static class Node&lt;U&gt;{ U item; Node&lt;U&gt; next; Node(){item=null;next=null;} Node(U item,Node&lt;U&gt; next){this.item=item;this.next=next;} boolean end(){return item == null &amp;&amp; next == null;} } private Node&lt;T&gt; top=new Node&lt;T&gt;(); public void push(T item){ top=new Node&lt;T&gt;(item,top); } public T pop(){ T result=top.item; if(!top.end()){ top=top.next; } return result; } public static void main(String[] args){ LinkedStack&lt;String&gt; lss=new LinkedStack&lt;String&gt;(); for(String s:\"Are you ok\".split){ lss.push(s); } String s; while((s=lss.pop())!=null) System.out.println(s); }} 这个例子使用末端哨兵（end sentinel）来判读堆栈何时为空。这个末端哨兵是在构造LinkedStack时创建的 RandomList就是一个范型类里包含了一个ArrayList，随机选择一个对象 范型接口范型也可以应用于接口 1public interface Generator&lt;T&gt;{T next();} 基本类型无法作为类型参数 1234567891011121314151617public class Fibonacci implements Generator&lt;Integer&gt;{ private int count=0; public Integer next(){return fib(count++)} private int fib(int n){ if(n&lt;2) return 1; return fib(n-1)+fib(n-2); } public static void main(String[] args){ Fibonacci gen=new Fabonacci(); for(int i=0;i&lt;11;i++){ syso(gen.next()+\" \"); } }} 范型方法范型可以用于整个类之上，也可以在类中包含参数化方法 是否拥有范型方法，与其所在的类是否是范型没有关系 定义范型方法，只需将范型参数列表置于返回值之前 12345public class GenericMethod{ public &lt;T&gt; void f(T x){ System.out.println(x.getClass().getName()); }} 方法拥有的参数类型，是由该方法的返回值类型前面的类型参数决定的 当使用范型类是，必须在创建对象时指定类型参数的值，而在使用范型方法时通常不必指明参数类型，因为编译器辉为我们找到具体的类型，这叫做类型参数推断(type argument inference) 我们可以像调用普通方法一样调用范型方法，就好像该方法被无限次地重载过 如果调用范型方法时传入了基本类型，自动打包机制就会介入其中，将基本类型的值包装为对应的对象 杠杆利用类型参数推断类型推断支队赋值操作有效 显式的类型说明 在范型方法中可以显示的指明类型，要显式的指明类型，必须在点操作符和方法名之间插入尖括号，然后把类型置入尖括号内，如果是在定义该方法的类的内部，必须在点操作符之前使用this关键字，如果是static方法，必须在点操作符之前加上类名 123456public class ExplicitTypeSpcification{ static void f(Map&lt;Person,List&lt;Pet&gt;&gt; petPeople){} public static void main(String[] args){ f(New.&lt;Persom,List&lt;Pet&gt;&gt;map()); }} 只有编写非赋值语句时，我们才需要这样额外的说明 可变参数和范型方法范型方法和可变参数列表可以很好的共存 123456789public class GenericVarargs{ public static &lt;T&gt; List&lt;T&gt; makeList(T...args){ List&lt;T&gt; result=new ArrayList&lt;T&gt;(); for(T item:args) result.add(item); return result; }} makeList()方法展示了和标准类库中的java.util.Arrays.asList()方法相同的功能 一个set实用工具作为范型方法的示例，set可以表达数学中的关系式,表达元素的并，交等运算 12345678910111213141516171819202122232425public class Sets{ public static &lt;T&gt; Set&lt;T&gt; union(Set&lt;T&gt; a,Set&lt;T&gt; b){ Set&lt;T&gt; result=new HashSet&lt;T&gt;(a); result.addAll(b); return result; } public static &lt;T&gt; Set&lt;T&gt; intersection(Set&lt;T&gt; a,Set&lt;T&gt; b){ Set&lt;T&gt; result= new HashSet&lt;T&gt;(a); result.retainAll(b); return result; } public static &lt;T&gt; Set&lt;T&gt; difference(Set&lt;T&gt; a,Set&lt;T&gt; b){ Set&lt;T&gt; result=new HashSet&lt;T&gt;(a); result.removeAll(b); return result; } public static &lt;T&gt; Set&lt;T&gt; complement(Set&lt;T&gt; a,Set&lt;T&gt; b){ return difference(union(a,b),intersection(a,b)); }} EnumSet是Java SE5中的新工具，用来从enum直接创建Set，其静态方法EnumSet.range()可以传入某个范围内的第一个元素和最后一个元素，然后它将返回一个set，包含该范围内的所有元素 1234567public enum Watercolor{ZINC,LEMON_YELLOW,....}public class WatercolorSets{Set&lt;Watercolors&gt; sets1 =EnumSet.range(ZINC,LEMON_YELLOW);} 匿名内部类范型可以应用于内部类及匿名内部类 构建复杂模型范型的一个重要好处是能够简单而安全的创建复杂模型 擦除的神秘之处同一种类的不同范型对象，通过getClass()得到的Class对象是相同的 根据JDK文档的描述，Class.getTypeParameters()将返回一个类型参数对象数组，表明有范型声明的类型参数。 在范型代码内部，无法获得任何有关范型参数类型的信息 Java范型是使用范擦除来实现的，这意味着你在使用范型时，任何具体的类型信息都被擦除了，你唯一知道的是你在使用一个对象 C++的方式java的范型是受C++启发的 在C++中，Manipulator类存储了一个类型T的对象，其方法调用了f()，因为C++的范型语法和Java有区别，在实例化这个模板时，C++编译器将进行检查，因此在该类被实例化的这一刻，它会看到HasF有一个方法f() 123456789101112131415161718192021#include &lt;iostream&gt;using namespace std;template&lt;class T&gt; class Manipulator{ T obj; public: Manipulator(T x){obj=x;} void manipulate{obj.f();}};class HasF{ public: void f(){cout&lt;&lt;\"hasF::f()\"&lt;&lt;endl;}};int main(){ HasF hf; Manipulator&lt;HasF&gt; manipulator(hf); manipulator.manipulate();} 而在Java上由于范型的擦除机制，Java编译器将manipulate()必须能够在obj上调用f()的这一需求映射到HasF拥有f()这一事实上，为类调用f()，我们必须协助范型类，给定范型类的边界，以此告知编译器只能接受这个边界的类型，这里是重用了extends关键字 1234567891011//octopusheep/HasF.javapublic class HasF{ public void f(){System.out.println(\"HasF.f()\");}}//octopusheep/Manipulation.javaclass Manipulator&lt;T extends HasF&gt;{ private T obj; Manipulator(T X){obj=x;} public void manipulate(){obj.f();}} 边界声明了T必须具有类型HasF或HasF导出的类型，这样就可以安全的在obj上调用f()了 迁移兼容性擦除的核心动机是它使得泛化的客户端可以使用非泛化的类库，反之亦然，这经常被成为”迁移兼容性” 擦除的问题为了关闭警告，Java提供了一个注解，这个注解在Java SE5之前的版本中不支持 1@SuppressWarnings(\"unchecked\") 边界处的动作对于在范型中创建数组，使用Array.newInstance()是推荐方式 通配符通配符允许在两个类型之间建立某种类型的向上转型关系 问题基本类型不能被当作参数类型 一个类不能实现同一个范型接口的两种变体","link":"/2019/04/30/《Java编程思想》读书笔记(第十五章)的副本/"}],"tags":[{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"Flutter","slug":"Flutter","link":"/tags/Flutter/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"Go","slug":"Go","link":"/tags/Go/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"RxJava","slug":"RxJava","link":"/tags/RxJava/"}],"categories":[{"name":"Programming","slug":"Programming","link":"/categories/Programming/"},{"name":"Java","slug":"Programming/Java","link":"/categories/Programming/Java/"},{"name":"Flutter","slug":"Programming/Flutter","link":"/categories/Programming/Flutter/"},{"name":"Go","slug":"Programming/Go","link":"/categories/Programming/Go/"}]}